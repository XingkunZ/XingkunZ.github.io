<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>《算法导论》|第一章 算法在计算中的作用</title>
    <url>/2020/06/28/%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%AE%97%E6%B3%95%E5%9C%A8%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
    <content><![CDATA[<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="问题与算法"><a href="#问题与算法" class="headerlink" title="问题与算法"></a>问题与算法</h2><p>现实中有很多需要解决的问题，一个<strong>问题</strong>可以看作是对<code>{输入}</code>期待某一种<code>{输出}</code>的过程。<strong>算法</strong>是用来解决一个良好定义的计算问题的工具，在现实中有着实际应用。正确的算法描述了<code>{输入}</code>与<code>{输出}</code>的转换关系。</p>
<p>衡量算法效率的常用标准是算法处理输入到得到输出所花费的<strong>时间</strong>。</p>
<h2 id="NP完全问题"><a href="#NP完全问题" class="headerlink" title="NP完全问题"></a>NP完全问题</h2><p>一个问题可能有多种候选的解决算法，但是寻找正确的算法是一件不容易的事情。有一些问题至今没有已知的有效算法，即<strong>NP完全问题</strong>，且至今也没有人能证明NP完全问题的有效算法是不存在的。</p>
<p>NP完全问题集有一个显著<strong>特点</strong>，如果该集合中的任何一个问题存在有效的算法，则该集合中的其他所有问题都存在有效算法。</p>
<p>许多NP完全问题在特定假设下存在着有效算法。</p>
<h1 id="算法作为一种技术"><a href="#算法作为一种技术" class="headerlink" title="算法作为一种技术"></a>算法作为一种技术</h1><p>有效的算法可以提升工程效率。计算时间是一种有限资源，好的算法可以节约时间和空间的资源。算法应当被看成一种技术，整个系统的性能不但依赖于选择快速的硬件，还依赖于选择有效的算法。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>《算法导论》</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统丨操作系统的功能是什么？</title>
    <url>/2020/06/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%A8%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8A%9F%E8%83%BD%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
    <content><![CDATA[<p>操作系统的三个主要功能是：进程管理、内存管理、存储管理。</p>
<h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><ul>
<li>在CPU上调度进程和线程</li>
<li>创建和删除用户进程和系统进程</li>
<li>挂起和重启进程</li>
<li>提供进程同步机制</li>
<li>提供进程通信机制</li>
</ul>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><ul>
<li>记录内存哪些部分被使用，被谁使用</li>
<li>决定哪些进程会调入或调出内存</li>
<li>根据需要分配和释放内存空间</li>
</ul>
<h1 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h1><h2 id="文件系统管理"><a href="#文件系统管理" class="headerlink" title="文件系统管理"></a>文件系统管理</h2><ul>
<li>创建和删除文件</li>
<li>创建和删除目录，组织文件</li>
<li>提供文件和目录的操作原语</li>
<li>映射文件到外存</li>
<li>备份文件到稳定、非易失的存储介质</li>
</ul>
<h2 id="大容量存储器管理"><a href="#大容量存储器管理" class="headerlink" title="大容量存储器管理"></a>大容量存储器管理</h2><ul>
<li>空闲空间管理</li>
<li>存储空间分配</li>
<li>硬盘调度</li>
<li>管理三级存储设备：安装和卸载设备媒介；为进程互斥使用而分配和释放设备；将数据从二级存储移动到三级存储。</li>
</ul>
<h2 id="高速缓存：高速缓存管理和置换策略"><a href="#高速缓存：高速缓存管理和置换策略" class="headerlink" title="高速缓存：高速缓存管理和置换策略"></a>高速缓存：高速缓存管理和置换策略</h2><ul>
<li>CPU—高速缓存—内存</li>
<li>可编程的内部存储器：寄存器分配与寄存器替换算法</li>
<li>硬件实现的高速缓存</li>
<li>内存可以看作外存的高速缓存</li>
</ul>
<h2 id="I-O系统"><a href="#I-O系统" class="headerlink" title="I/O系统"></a>I/O系统</h2><ul>
<li>缓冲、高偶素缓存和假脱机的内存管理组件</li>
<li>设备驱动器的通用接口</li>
<li>特定硬件设备的驱动程序</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Packetdrill使用方法，结合tcpdump监测</title>
    <url>/2020/06/25/Packetdrill%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%8C%E7%BB%93%E5%90%88tcpdump%E7%9B%91%E6%B5%8B/</url>
    <content><![CDATA[<h1 id="Packetdrill"><a href="#Packetdrill" class="headerlink" title="Packetdrill"></a>Packetdrill</h1><p><a href="https://blog.csdn.net/zhangmeimei_pku/article/details/79562879">细读P4论文(Programming Protocol-Independent Packet Processors)</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/61593853">packetdrill是什么  入门demo</a></p>
<h2 id="Install-and-Usage"><a href="#Install-and-Usage" class="headerlink" title="Install and Usage"></a>Install and Usage</h2><p>下载地址：<a href="https://github.com/google/packetdrill">https://github.com/google/packetdrill</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> root</span><br><span class="line"><span class="meta">#</span> 需要下载flex,bison</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br><span class="line">sudo apt-get install flex bison</span><br><span class="line"><span class="meta">#</span> 解压代码，配置编译</span><br><span class="line">unzip packetdrill-master.zip</span><br><span class="line">cd packetdrill-master/gtests/net/packetdrill</span><br><span class="line">./configure &amp; make</span><br><span class="line"><span class="meta">#</span> 执行</span><br><span class="line">./packetdrill ./tests/linux/packetdrill/XXX.pkt</span><br></pre></td></tr></table></figure>
<h2 id="添加环境变量-方便执行，不必须"><a href="#添加环境变量-方便执行，不必须" class="headerlink" title="添加环境变量(方便执行，不必须)"></a>添加环境变量(方便执行，不必须)</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /root/.bashrc</span><br><span class="line"><span class="meta">#</span> 添加环境配置：在末尾添加代码</span><br><span class="line"><span class="meta">#</span> export PATH="/usr/local/packetdrill:$PATH"</span><br></pre></td></tr></table></figure>
<p>将编译出的packetdrill可执行文件拷贝到/usr/local/bin目录下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp /home/kun/Downloads/packetdrill-master/gtests/net/packetdrill/packetdrill /usr/local/bin</span><br></pre></td></tr></table></figure>
<h2 id="执行-tcpdump监测"><a href="#执行-tcpdump监测" class="headerlink" title="执行+tcpdump监测"></a>执行+tcpdump监测</h2><p>编写test.pkt文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0 socket(..., SOCK_STREAM, IPPROTO_TCP) = 3</span><br><span class="line">+0  setsockopt(3, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0</span><br><span class="line">+0  bind(3, ..., ...) = 0</span><br><span class="line">+0  listen(3, 1) = 0</span><br><span class="line"></span><br><span class="line">//TCP three-way handshake</span><br><span class="line">+0  &lt; S 0:0(0) win 4000 &lt;mss 1000&gt;</span><br><span class="line">+0  &gt; S. 0:0(0) ack 1 &lt;...&gt;</span><br><span class="line">+.1 &lt; . 1:1(0) ack 1 win 1000</span><br><span class="line"></span><br><span class="line">+0 accept(3, ..., ...) = 4</span><br><span class="line"></span><br><span class="line">+0 &lt; P. 1:201(200) win 4000</span><br><span class="line">+0 &gt; . 1:1(0) ack 201</span><br></pre></td></tr></table></figure>
<p>打开终端1，用tcpdump监测8080端口（bind默认绑定端口）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># sudo tcpdump -i any port 8080 -nn </span></span><br><span class="line">tcpdump: verbose output suppressed, use -v or -vv <span class="keyword">for</span> full protocol decode</span><br><span class="line">listening on any, link-type LINUX_SLL (Linux cooked), capture size 262144 bytes</span><br></pre></td></tr></table></figure>
<p>打开终端2执行上面的pkt测试脚本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">packetdrill test.pkt</span><br></pre></td></tr></table></figure>
<p>这时终端1监测到的信息如下:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">13:33:36.573132 IP 192.0.2.1.49941 &gt; 192.168.22.185.8080: Flags [S], seq 0, win 4000, options [mss 1000], length 0</span><br><span class="line">13:33:36.573542 IP 192.168.22.185.8080 &gt; 192.0.2.1.49941: Flags [S.], seq 815367284, ack 1, win 29200, options [mss 1460], length 0</span><br><span class="line">13:33:36.675100 IP 192.0.2.1.49941 &gt; 192.168.22.185.8080: Flags [.], ack 1, win 1000, length 0</span><br><span class="line">13:33:36.675187 IP 192.0.2.1.49941 &gt; 192.168.22.185.8080: Flags [P.], seq 1:201, ack 0, win 4000, length 200: HTTP</span><br><span class="line">13:33:36.675204 IP 192.168.22.185.8080 &gt; 192.0.2.1.49941: Flags [.], ack 201, win 30000, length 0</span><br><span class="line">13:33:36.675997 IP 192.168.22.185.8080 &gt; 192.0.2.1.49941: Flags [R.], seq 1, ack 201, win 30000, length 0</span><br><span class="line">13:33:36.676023 IP 192.0.2.1.49941 &gt; 192.168.22.185.8080: Flags [R.], seq 201, ack 0, win 4000, length 0</span><br><span class="line">^C</span><br><span class="line">7 packets captured</span><br><span class="line">7 packets received by filter</span><br><span class="line">0 packets dropped by kernel</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>gcov,lcov使用方法|普通程序测试和linux内核测试</title>
    <url>/2020/06/25/gcov-lcov%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95-%E6%99%AE%E9%80%9A%E7%A8%8B%E5%BA%8F%E6%B5%8B%E8%AF%95%E5%92%8Clinux%E5%86%85%E6%A0%B8%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h1 id="gcov"><a href="#gcov" class="headerlink" title="gcov"></a>gcov</h1><h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install gcov</span><br></pre></td></tr></table></figure>
<h2 id="普通程序"><a href="#普通程序" class="headerlink" title="普通程序"></a>普通程序</h2><p>当前目录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@ubuntu:/home/kun/Documents/test#</span><br></pre></td></tr></table></figure>
<p>编译源文件test，生成twonumber可执行文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -fprofile-arcs -ftest-coverage -o twonumber test.c</span><br></pre></td></tr></table></figure>
<p>生成以下两个文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test.gcno  twonumber</span><br></pre></td></tr></table></figure>
<p>.gcno是由<code>-ftest-coverage</code>产生的，它包含了重建基本块图和相应的块的源码的行号的信息。</p>
<p><strong>执行twonumber。</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./twonumber</span><br></pre></td></tr></table></figure>
<p>生成下面的文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test.gcda</span><br></pre></td></tr></table></figure>
<p>.gcda是由加了<code>-fprofile-arcs</code>编译参数的编译后的文件运行所产生的，它包含了弧跳变的次数和其他的概要信息（而gcda只能在程序运行完毕后才能产生的）</p>
<p><strong>Gcov执行函数覆盖、语句覆盖和分支覆盖。</strong>有几个.c就执行几次。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcov test.c #默认保存覆盖率文件为test.c.gcov</span><br><span class="line">gcov test.c&gt;&gt;test_cov #保存覆盖率文件为test_cov</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">File 'test.c'</span><br><span class="line">Lines executed:51.85% of 27</span><br><span class="line">Creating 'test.c.gcov'</span><br></pre></td></tr></table></figure>
<p>生成覆盖率文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test.c.gcov</span><br></pre></td></tr></table></figure>
<p>查看该文件可以看到代码执行情况。</p>
<p><a href="https://blog.csdn.net/yukin_xue/article/details/7653482">https://blog.csdn.net/yukin_xue/article/details/7653482</a></p>
<p><strong>注：一次编译后，执行多次（若执行路径不同），gcov统计出的信息也不同。</strong></p>
<h2 id="内核覆盖率"><a href="#内核覆盖率" class="headerlink" title="内核覆盖率"></a>内核覆盖率</h2><p>进入内核源文件（这是当初gcc编译内核的位置）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/src/linux-4.6/</span><br></pre></td></tr></table></figure>
<p><strong>执行gcov进行覆盖统计，生成”gcov”文件</strong>。gcov文件需要有gcda和gcno文件（执行的统计信息）的支持才能产生。所需要用到的统计信息放在/sys/kernel/debug/gcov/{内核源文件路径}/kernel/gcov/，因此需要-o。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcov kernel/gcov/base.c -o /sys/kernel/debug/gcov/usr/src/linux-4.6/kernel/gcov/</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">File 'kernel/gcov/base.c'</span><br><span class="line">Lines executed:68.18% of 44</span><br><span class="line">Creating 'base.c.gcov'</span><br><span class="line"></span><br><span class="line">File 'include/linux/module.h'</span><br><span class="line">Lines executed:100.00% of 5</span><br><span class="line">Creating 'module.h.gcov'</span><br></pre></td></tr></table></figure>
<p>‘base.c.gcov’以及其<strong>包含文件</strong>的覆盖率文件”.gcov”都会生成在<strong>用户当前所在目录</strong>下。</p>
<p><strong>注意</strong>：gcov命令依旧只能在当初<strong>编译的目录下</strong>进行，否则会找不到源码文件，生成的.gcov文件是残缺的。也就是说<strong>只能在编译的目录下生成完整的gcov文件。</strong></p>
<p>尝试查看其他文件的覆盖内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcov net/ipv4/xfrm4_state.c -o /sys/kernel/debug/gcov/usr/src/linux-4.6/net/ipv4/</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">File 'include/net/xfrm.h'</span><br><span class="line">Lines executed:0.00% of 13</span><br><span class="line">Creating 'xfrm.h.gcov'</span><br><span class="line"></span><br><span class="line">File 'net/ipv4/xfrm4_state.c'</span><br><span class="line">Lines executed:7.50% of 40</span><br><span class="line">Creating 'xfrm4_state.c.gcov'</span><br><span class="line"></span><br><span class="line">File 'include/linux/skbuff.h'</span><br><span class="line">Lines executed:0.00% of 1</span><br><span class="line">Creating 'skbuff.h.gcov'</span><br><span class="line"></span><br><span class="line">File 'include/net/net_namespace.h'</span><br><span class="line">Lines executed:0.00% of 1</span><br><span class="line">Creating 'net_namespace.h.gcov'</span><br></pre></td></tr></table></figure>
<p>此时，<code>xfrm4_state.c.gcov、xfrm.h.gcov、net_namespace.h.gcov、skbuff.h.gcov</code>在编译目录下生成。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@ubuntu:/usr/src/linux-4.6# ls</span><br><span class="line">arch           Kconfig               scripts</span><br><span class="line">block          kernel                security</span><br><span class="line">certs          lib                   skbuff.h.gcov</span><br><span class="line">COPYING        MAINTAINERS           sound</span><br><span class="line">CREDITS        Makefile              System.map</span><br><span class="line">crypto         mm                    tools</span><br><span class="line">Documentation  modules.builtin       usr</span><br><span class="line">drivers        modules.order         virt</span><br><span class="line">firmware       Module.symvers        vmlinux</span><br><span class="line">fs             net                   vmlinux.o</span><br><span class="line">include        net_namespace.h.gcov  xfrm4_state.c.gcov</span><br><span class="line">init           README                xfrm.h.gcov</span><br><span class="line">ipc            REPORTING-BUGS</span><br><span class="line">Kbuild         samples</span><br></pre></td></tr></table></figure>
<h3 id="net-ipv4-icmp-c"><a href="#net-ipv4-icmp-c" class="headerlink" title="net/ipv4/icmp.c"></a>net/ipv4/icmp.c</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcov net/ipv4/icmp.c -o /sys/kernel/debug/gcov/usr/src/linux-4.6/net/ipv4/</span><br><span class="line">File 'net/ipv4/icmp.c'</span><br><span class="line">Lines executed:61.14% of 332</span><br><span class="line">Creating 'icmp.c.gcov'</span><br><span class="line"></span><br><span class="line">File 'include/net/l3mdev.h'</span><br><span class="line">Lines executed:100.00% of 1</span><br><span class="line">Creating 'l3mdev.h.gcov'</span><br><span class="line"></span><br><span class="line">File 'include/net/inetpeer.h'</span><br><span class="line">Lines executed:0.00% of 4</span><br><span class="line">Creating 'inetpeer.h.gcov'</span><br><span class="line"></span><br><span class="line">File 'include/net/sock.h'</span><br><span class="line">Lines executed:100.00% of 1</span><br><span class="line">Creating 'sock.h.gcov'</span><br><span class="line"></span><br><span class="line">File 'arch/x86/include/asm/bitops.h'</span><br><span class="line">Lines executed:100.00% of 1</span><br><span class="line">Creating 'bitops.h.gcov'</span><br><span class="line"></span><br><span class="line">File 'include/linux/cpumask.h'</span><br><span class="line">Lines executed:100.00% of 1</span><br><span class="line">Creating 'cpumask.h.gcov'</span><br><span class="line"></span><br><span class="line">File 'include/net/inet_common.h'</span><br><span class="line">Lines executed:100.00% of 2</span><br><span class="line">Creating 'inet_common.h.gcov'</span><br><span class="line"></span><br><span class="line">File 'include/linux/skbuff.h'</span><br><span class="line">Lines executed:52.94% of 51</span><br><span class="line">Creating 'skbuff.h.gcov'</span><br><span class="line"></span><br><span class="line">File 'include/net/net_namespace.h'</span><br><span class="line">Lines executed:100.00% of 1</span><br><span class="line">Creating 'net_namespace.h.gcov'</span><br><span class="line"></span><br><span class="line">File 'include/net/xfrm.h'</span><br><span class="line">Lines executed:72.73% of 11</span><br><span class="line">Creating 'xfrm.h.gcov'</span><br><span class="line"></span><br><span class="line">File 'arch/x86/include/asm/atomic64_64.h'</span><br><span class="line">Lines executed:100.00% of 1</span><br><span class="line">Creating 'atomic64_64.h.gcov'</span><br><span class="line"></span><br><span class="line">File 'include/linux/compiler.h'</span><br><span class="line">Lines executed:100.00% of 1</span><br><span class="line">Creating 'compiler.h.gcov'</span><br><span class="line"></span><br><span class="line">File 'include/linux/slab.h'</span><br><span class="line">Lines executed:100.00% of 1</span><br><span class="line">Creating 'slab.h.gcov'</span><br><span class="line"></span><br><span class="line">File 'include/net/route.h'</span><br><span class="line">Lines executed:33.33% of 9</span><br><span class="line">Creating 'route.h.gcov'</span><br><span class="line"></span><br><span class="line">File 'include/net/ip.h'</span><br><span class="line">Lines executed:100.00% of 1</span><br><span class="line">Creating 'ip.h.gcov'</span><br><span class="line"></span><br><span class="line">File 'include/linux/err.h'</span><br><span class="line">Lines executed:66.67% of 3</span><br><span class="line">Creating 'err.h.gcov'</span><br><span class="line"></span><br><span class="line">File 'include/net/dst.h'</span><br><span class="line">Lines executed:14.29% of 7</span><br><span class="line">Creating 'dst.h.gcov'</span><br><span class="line"></span><br><span class="line">File 'include/linux/spinlock.h'</span><br><span class="line">Lines executed:66.67% of 3</span><br><span class="line">Creating 'spinlock.h.gcov'</span><br><span class="line"></span><br><span class="line">File 'include/net/ip_fib.h'</span><br><span class="line">Lines executed:100.00% of 2</span><br><span class="line">Creating 'ip_fib.h.gcov'</span><br><span class="line"></span><br><span class="line">File 'include/linux/jhash.h'</span><br><span class="line">Lines executed:100.00% of 7</span><br><span class="line">Creating 'jhash.h.gcov'</span><br><span class="line"></span><br><span class="line">File 'arch/x86/include/asm/checksum_64.h'</span><br><span class="line">Lines executed:100.00% of 5</span><br><span class="line">Creating 'checksum_64.h.gcov'</span><br><span class="line"></span><br><span class="line">File 'include/net/checksum.h'</span><br><span class="line">Lines executed:100.00% of 1</span><br><span class="line">Creating 'checksum.h.gcov'</span><br><span class="line"></span><br><span class="line">File 'include/linux/bitops.h'</span><br><span class="line">Lines executed:50.00% of 2</span><br><span class="line">Creating 'bitops.h.gcov'</span><br><span class="line"></span><br><span class="line">File 'arch/x86/include/asm/paravirt.h'</span><br><span class="line">Lines executed:0.00% of 1</span><br><span class="line">Creating 'paravirt.h.gcov'</span><br><span class="line"></span><br><span class="line">File 'include/linux/spinlock_api_smp.h'</span><br><span class="line">Lines executed:0.00% of 1</span><br><span class="line">Creating 'spinlock_api_smp.h.gcov'</span><br><span class="line"></span><br><span class="line">File 'arch/x86/include/asm/preempt.h'</span><br><span class="line">Lines executed:100.00% of 1</span><br><span class="line">Creating 'preempt.h.gcov'</span><br><span class="line"></span><br><span class="line">File 'include/linux/bottom_half.h'</span><br><span class="line">Lines executed:50.00% of 2</span><br><span class="line">Creating 'bottom_half.h.gcov'</span><br><span class="line"></span><br><span class="line">File 'arch/x86/include/asm/atomic.h'</span><br><span class="line">Lines executed:0.00% of 1</span><br><span class="line">Creating 'atomic.h.gcov'</span><br></pre></td></tr></table></figure>
<p>执行了一个ping命令后，再次查看覆盖率：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcov net/ipv4/icmp.c -o /sys/kernel/debug/gcov/usr/src/linux-4.6/net/ipv4/</span><br><span class="line">File 'net/ipv4/icmp.c'</span><br><span class="line">Lines executed:61.75% of 332</span><br><span class="line">Creating 'icmp.c.gcov'</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>icmp.c的覆盖率有变化。</p>
<h1 id="lcov"><a href="#lcov" class="headerlink" title="lcov"></a>lcov</h1><h2 id="下载安装-1"><a href="#下载安装-1" class="headerlink" title="下载安装"></a>下载安装</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install lcov</span><br></pre></td></tr></table></figure>
<h2 id="普通程序-1"><a href="#普通程序-1" class="headerlink" title="普通程序"></a>普通程序</h2><p>当前目录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@ubuntu:/home/kun/Documents/test#</span><br></pre></td></tr></table></figure>
<p>已经编译过：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">test  test.c  test.gcda  test.gcno  test.h</span><br></pre></td></tr></table></figure>
<p>扫描指定目录下的.gcno文件，生成<strong>基准数据文件</strong>，此处起名init.info：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -c捕获,收集运行后所产生的信息 -i初始化 -d工作目录 -o输出文件</span></span><br><span class="line">lcov -c -i -d [源码工作目录] -o [基准数据文件名]</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lcov -c -i -d ./ -o init.info</span><br><span class="line">Capturing coverage data from ./</span><br><span class="line">Found gcov version: 5.4.0</span><br><span class="line">Scanning ./ for .gcno files ...</span><br><span class="line">Found 1 graph files in ./</span><br><span class="line">Processing test.gcno</span><br><span class="line">Finished .info-file creation</span><br></pre></td></tr></table></figure>
<p><strong>执行程序</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./test</span><br></pre></td></tr></table></figure>
<p>扫描指定目录下的.gcda文件，生成<strong>覆盖率文件</strong>，此处起名cover.info：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lcov -c -d ./ -o cover.info</span><br><span class="line">Capturing coverage data from ./</span><br><span class="line">Found gcov version: 5.4.0</span><br><span class="line">Scanning ./ for .gcda files ...</span><br><span class="line">Found 1 data files in ./</span><br><span class="line">Processing test.gcda</span><br><span class="line">Finished .info-file creation</span><br></pre></td></tr></table></figure>
<p>合并<strong>基准数据文件</strong>和<strong>覆盖率文件</strong>，生成一个总数据文件，total.info：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -a合并 [文件名之一]</span></span><br><span class="line">lcov -a init.info -a cover.info -o total.info</span><br><span class="line">Combining tracefiles.</span><br><span class="line">Reading tracefile init.info</span><br><span class="line">Reading tracefile cover.info</span><br><span class="line">Writing data to total.info</span><br><span class="line">Summary coverage rate:</span><br><span class="line">  lines......: 64.9% (24 of 37 lines)</span><br><span class="line">  functions..: 80.0% (4 of 5 functions)</span><br><span class="line">  branches...: no data found</span><br></pre></td></tr></table></figure>
<p>如果有不需要的信息可以删掉（可省略这步）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> --remove 删除统计信息中如下的代码或文件，支持正则</span></span><br><span class="line">lcov --remove total.info '*/usr/include/*' -o total.info</span><br></pre></td></tr></table></figure>
<p>通过总数据文件生成html文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -o 输出的文件夹</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --legend 简单的统计信息说明</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --title 项目名称，最后会出现在html页里<span class="built_in">test</span>一项</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --prefix 将要生成的html文件路径（基于[输出的文件夹]）</span></span><br><span class="line">genhtml -o cover_report --legend --title "lcov-test" --prefix=./ total.info</span><br></pre></td></tr></table></figure>
<p>生成的文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls</span><br><span class="line">cover.info    init.info  test.c     test.gcno  total.info</span><br><span class="line">cover_report  test       test.gcda  test.h</span><br></pre></td></tr></table></figure>
<p>cover_report/下，浏览器打开<strong>index.html文件</strong>则可以看到结果:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls</span><br><span class="line">amber.png    glass.png   index-sort-f.html  snow.png</span><br><span class="line">emerald.png  home        index-sort-l.html  updown.png</span><br><span class="line">gcov.css     index.html  ruby.png</span><br></pre></td></tr></table></figure>
<p><strong>常用参数</strong>：</p>
<ol>
<li>-d 项目路径，即.gcda .gcno所在的路径</li>
<li>-a 合并（归并）多个lcov生成的info文件</li>
<li>-c 捕获，也即收集代码运行后所产生的统计计数信息</li>
<li>—external 捕获其它目录产生的统计计数文件</li>
<li>-i/—initial 初始化所有的覆盖率信息，作为基准数据</li>
<li>-o 生成处理后的文件</li>
<li>-r/—remove 移除不需要关注的覆盖率信息文件</li>
<li>-z 重置所有执行程序所产生的统计信息为0</li>
</ol>
<h2 id="内核覆盖率-1"><a href="#内核覆盖率-1" class="headerlink" title="内核覆盖率"></a>内核覆盖率</h2><p><a href="https://github.com/linux-test-project/lcov">linux-test-project</a></p>
<p>As root:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lcov --zerocounters</span><br></pre></td></tr></table></figure>
<p><strong>捕捉当前覆盖状态</strong>，存于一个文件（需要等几分钟）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lcov -c -o lcov_res/kernel.info</span><br><span class="line">...</span><br><span class="line">Processing crypto/gf128mul.gcda</span><br><span class="line">Processing crypto/gcm.gcda</span><br><span class="line">Processing crypto/ghash-generic.gcda</span><br><span class="line">Finished .info-file creation</span><br><span class="line">Removing temporary directories.</span><br></pre></td></tr></table></figure>
<p><strong>生成html输出</strong>。读当前文件/lcov_res/kernel.info，在当前目录/cover_report/下生成html文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">genhtml -o cover_report --legend --title "kernel_cov" --prefix=./ lcov_res/kernel.info</span><br><span class="line">...</span><br><span class="line">Processing file /usr/src/linux-4.6/sound/pci/ens1370.c</span><br><span class="line">Processing file /usr/src/linux-4.6/sound/pci/ac97/ac97_pcm.c</span><br><span class="line">Processing file /usr/src/linux-4.6/sound/pci/ac97/ac97_patch.c</span><br><span class="line">Processing file /usr/src/linux-4.6/sound/pci/ac97/ac97_codec.c</span><br><span class="line">Processing file /usr/src/linux-4.6/sound/pci/ac97/ac97_proc.c</span><br><span class="line">Writing directory view page.</span><br><span class="line">Overall coverage rate:</span><br><span class="line">  lines......: 7.0% (42498 of 605635 lines)</span><br><span class="line">  functions..: 8.7% (4784 of 54929 functions)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>测试</tag>
        <tag>gcov/lcov</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux网络内核源码分析|网络层之IP层处理</title>
    <url>/2020/02/25/Linux%E7%BD%91%E7%BB%9C%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E7%BD%91%E7%BB%9C%E5%B1%82%E4%B9%8BIP%E5%B1%82%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="关于IPv4"><a href="#关于IPv4" class="headerlink" title="关于IPv4"></a>关于IPv4</h1><h2 id="IP简述"><a href="#IP简述" class="headerlink" title="IP简述"></a>IP简述</h2><p>IP包通过路由器向正确的方向跳转，以达到转发数据的效果。为了完成正确的效果，数据包必须包含源地址和目的地址。</p>
<p>IP支持数据分片。如果数据过长，则将其分成一片一片的分片再发送。分片到达目的地的顺序可能与发送顺序不同，因此IP需要将分片重新组成原来的数据段。</p>
<h2 id="IPv4数据包"><a href="#IPv4数据包" class="headerlink" title="IPv4数据包"></a>IPv4数据包</h2><img src="/2020/02/25/Linux网络内核源码分析-网络层之IP层处理/ip数据包.PNG">
<p>一个数IPv4数据包由头部和数据构成，数据中记录了传输层信息内容。</p>
<h1 id="IPv4模块处理流程"><a href="#IPv4模块处理流程" class="headerlink" title="IPv4模块处理流程"></a>IPv4模块处理流程</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>从传输层到IP层发送数据包：</strong></p>
<ul>
<li>UDP模块调用函数<code>ip_push_pending_frames()</code>进入IP层。</li>
<li>TCP模块调用函数<code>ip_queue_xmit()</code>进入IP层。</li>
</ul>
<p>这两个函数都为数据包封装了IP协议信息，把对应的头部加到套接字缓冲区内。</p>
<img src="/2020/02/25/Linux网络内核源码分析-网络层之IP层处理/ip模块处理流程.PNG">
<p><code>ip_queue_xmit()</code>会调用<code>ip_route_output_flow()</code>查找路由表：为套接字缓冲区设置路由出口信息。如果已有TCP连接，则套接字缓冲区保存了路由信息，则不需要这一步。</p>
<p><strong>两条路下来，都调用<code>dst_output()</code>进入IP层发送流程：</strong></p>
<p><code>dst_output()→ip_output()→ip_finish_output()→ip_finish_output2()→邻居子系统调用接口函数dev_queue_xmit()→底层网络设备驱动程序</code></p>
<p><strong>如果是接收数据包:</strong></p>
<p>网络设备驱动会通过接口<code>netif_rx()</code>把数据包递交给<code>ip_rcv()</code>，进入IP层。接着调用：<code>ip_rcv_finish()作数据包处理→ip_route_input为数据包查询路由信息，确定是转发/交付本地。如果是需要转发的，则不用再次查询路由。</code>接着，<code>ip_rcv_finish()→dst_input()分情况处理数据包：转发/交付本地</code>。</p>
<p><strong>对于交付本地的数据包：</strong></p>
<p><code>dst_input()→ip_local_deliver()对要交付的数据包进一步处理→ip_local_deliver_finish()把数据包交给传输层</code></p>
<p><strong>对于要转发的数据包：</strong></p>
<p><code>dst_input()→ip_forward()→ip_forward_finish()</code>，之后就按照发送数据包的方式发送，路由信息早已设置好。</p>
<h2 id="发送数据包"><a href="#发送数据包" class="headerlink" title="发送数据包"></a>发送数据包</h2><h3 id="从UDP发：ip-push-pending-frames-sk-ip-output-c"><a href="#从UDP发：ip-push-pending-frames-sk-ip-output-c" class="headerlink" title="从UDP发：ip_push_pending_frames(sk) ip_output.c"></a>从UDP发：ip_push_pending_frames(sk) <code>ip_output.c</code></h3><p>大致的功能：封装IP头部信息，进入IP层的发送流程。</p>
<ol>
<li>通过sk中的struct inet_opt结构获得路由表项信息。sk中的inet-&gt;cork.rt是udp_sendmsg调用ip_append_data时指定的，记录了ip_route_output_flow查找路由表所返回的路由表项信息。此处将信息记录在struct rtable *rt中。<ol>
<li>rt的rt-&gt;u.dst决定了套接字缓冲区skb数据如何进一步发送。</li>
</ol>
</li>
<li>检查套接字发送队列是否为空，并返回队首的套接字缓冲区，存为skb。</li>
<li>遍历套接字发送队列，调整数据长度。</li>
<li>获得分片标志：df。</li>
<li>获取TTL：ttl。</li>
<li>将套接字缓冲区中的data所指区域强制转换成struct iphdr结构。<ol>
<li>通过设置iph的信息：TOS、总长度、标志号等IP头部信息。</li>
<li>计算校验和并设置IP头部的校验和字段，<code>ip_send_check()</code>。</li>
</ol>
</li>
<li><code>skb-&gt;dst = dst_clone(&amp;rt-&gt;u.dst);</code>为套接字缓冲区指定了路由表项信息。<strong>从传输层到IP层的至关重要的一步。</strong><ol>
<li>即，为数据包进入IP发送流程设置了具体方法（<strong>skb-&gt;dst-&gt;output = ip_output</strong>）。</li>
<li><strong>此时，程序已经为dst_output配置完skb处理信息。</strong></li>
</ol>
</li>
<li><code>err = NF_HOOK(PF_INET, NF_IP_LOCAL_OUT, skb, NULL, skb-&gt;dst-&gt;dev, dst_output)</code>。内核将从这里转到dst_output函数，通过ip_output函数进入IP发送流程。</li>
</ol>
<h3 id="从TCP发：ip-queue-xmit-skb-ipfragok-ip-output-c"><a href="#从TCP发：ip-queue-xmit-skb-ipfragok-ip-output-c" class="headerlink" title="从TCP发：ip_queue_xmit(skb,ipfragok) ip_output.c"></a>从TCP发：ip_queue_xmit(skb,ipfragok) <code>ip_output.c</code></h3><p>TCP模块调用该函数处理数据包，该函数与<code>ip_push_pending_frames()</code>相似：封装IP头部信息，进入IP层的发送流程。</p>
<ol>
<li>得到套接字缓冲区曾经记录的路由表项信息，写入变量rt中。</li>
<li>确认套接字缓存的路由是否有效，并返回给变量rt，<code>__sk_dst_check(sk,0)</code>。</li>
<li>建立TCP连接后，路由表项信息被保存在套接字缓冲区中。<ol>
<li>如果没有缓存的路由表项，则查找路由表<code>ip_route_output_flow()</code>，获取路由表项信息，把路由信息返回给rt。</li>
</ol>
</li>
<li><strong>重要步骤</strong>：为数据包进入IP发送流程设置具体方法：<code>skb-&gt;dst = dst_clone(&amp;rt-&gt;u.dst)</code>。</li>
<li>在套接字缓冲区中为IP头部留下IP头部空间，<code>skb_push()</code>。</li>
<li>设置IP头部协议信息。</li>
<li>构建IP选项信息：给iph的各项元素赋值。</li>
<li>设置IP包的头部标识符；设置IP校验和<code>ip_send_check()</code>。</li>
<li><strong>此时，已经配置了必要的skb信息，为发送了足够的准备。</strong></li>
<li><code>NF_HOOK(PF_INET, NF_IP_LOCAL_OUT, skb, NULL, rt-&gt;u.dst.dev,dst_output);</code>内核将从这里转到dst_output函数，通过ip_output函数进入IP层处理。</li>
</ol>
<h3 id="dst-output-skb-net-dst-h"><a href="#dst-output-skb-net-dst-h" class="headerlink" title="dst_output(skb) /net/dst.h"></a>dst_output(skb) <code>/net/dst.h</code></h3><p>该函数的任务是把套接字缓冲区(skb)中的数据发送出去，具体去向由路由表项的出口信息决定。</p>
<p>dst_output通过struct dst_entry的output指针进入具体的IP发送流程。所以此前要指定具体函数，这一步在UDP的udp_sendmsg()完成或TCP的ip_queue_xmit()完成。</p>
<p>此时skb-&gt;dst-&gt;output已经指向ip_output()函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Output packet to network from transport.  */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dst_output</span><span class="params">(struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="comment">// 这里实际调用了ip_output函数</span></span><br><span class="line">		err = skb-&gt;dst-&gt;output(&amp;skb);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (likely(err == <span class="number">0</span>))</span><br><span class="line">			<span class="keyword">return</span> err;</span><br><span class="line">		<span class="keyword">if</span> (unlikely(err != NET_XMIT_BYPASS))</span><br><span class="line">			<span class="keyword">return</span> err;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ip-output-pskb-ip-output-c"><a href="#ip-output-pskb-ip-output-c" class="headerlink" title="ip_output(pskb) ip_output.c"></a>ip_output(pskb) <code>ip_output.c</code></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ip_output</span><span class="params">(struct sk_buff **pskb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span> = *<span class="title">pskb</span>;</span></span><br><span class="line"></span><br><span class="line">	IP_INC_STATS(IPSTATS_MIB_OUTREQUESTS);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果数据包太大而不能再网络设备上传输，则将其分成一些小分片</span></span><br><span class="line">	<span class="keyword">if</span> ((skb-&gt;len &gt; dst_pmtu(skb-&gt;dst) || skb_shinfo(skb)-&gt;frag_list) &amp;&amp;</span><br><span class="line">	    !skb_shinfo(skb)-&gt;tso_size)</span><br><span class="line">		<span class="keyword">return</span> ip_fragment(skb, ip_finish_output);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> ip_finish_output(skb);</span><br><span class="line">    <span class="comment">// 进入ip_finish_output()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ip-finish-output-skb-ip-output-c"><a href="#ip-finish-output-skb-ip-output-c" class="headerlink" title="ip_finish_output(skb) ip_output.c"></a>ip_finish_output(skb) <code>ip_output.c</code></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ip_finish_output</span><span class="params">(struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">dev</span> = <span class="title">skb</span>-&gt;<span class="title">dst</span>-&gt;<span class="title">dev</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置套接字缓冲区数据的发送设备</span></span><br><span class="line">	skb-&gt;dev = dev;</span><br><span class="line">	<span class="comment">// 设置所用的协议为IP协议</span></span><br><span class="line">	skb-&gt;protocol = htons(ETH_P_IP);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 通过过滤器进入ip_finish_output2</span></span><br><span class="line">	<span class="keyword">return</span> NF_HOOK(PF_INET, NF_IP_POST_ROUTING, skb, <span class="literal">NULL</span>, dev,</span><br><span class="line">		       ip_finish_output2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ip-finish-output2-skb-ip-output-c"><a href="#ip-finish-output2-skb-ip-output-c" class="headerlink" title="ip_finish_output2(skb) ip_output.c"></a>ip_finish_output2(skb) <code>ip_output.c</code></h3><ol>
<li>通过套接字缓冲区的struct dst_entry指针访问邻居子系统:<code>dst-&gt;neighbour</code>。</li>
<li>如果有缓存指针hh，则通过hh-&gt;output发送数据：hh_output指向一个发送数据的接口函数，比如dev_queue_xmit。</li>
<li>如果缓存指针hh为空，则通过dst-&gt;neighbour-&gt;output发送数据：output指向一个发送数据的接口函数，比如dev_queue_xmit。</li>
</ol>
<h2 id="IP包的本地接收"><a href="#IP包的本地接收" class="headerlink" title="IP包的本地接收"></a>IP包的本地接收</h2><h3 id="流程概述"><a href="#流程概述" class="headerlink" title="流程概述"></a>流程概述</h3><p><code>ip_rcv()→ ip_rcv_finish() →确定要交付本地dst_input() →ip_local_deliver()→ip_local_deliver_finish()向上层协议下注册的套接字递交该数据包</code></p>
<h3 id="ip-rcv-skb-dev-pt-net-ipv4-ip-input-c"><a href="#ip-rcv-skb-dev-pt-net-ipv4-ip-input-c" class="headerlink" title="ip_rcv(skb,dev,pt) net/ipv4/ip_input.c"></a>ip_rcv(skb,dev,pt) <code>net/ipv4/ip_input.c</code></h3><p>该函数作一些格式化检查工作：判断数据包是不是发给本地的、检查头部长度是否正确、检查校验和、去掉填充字段等。然后调用<code>ip_rcv_finish()</code>。</p>
<ol>
<li>丢弃发给其他主机的数据包。</li>
<li>检查数据包长度是否为IP头部的长度：<code>pskb_may_pull(skb,sizeof(iphdr))</code>。</li>
<li>得到IP包的包头起始位置iph。</li>
<li>检查数据包是否为IPv4格式包：ipv4-&gt;ihl/version。</li>
<li>检查套接字缓冲区是否组偶容纳数据包指定长度的报头。</li>
<li>检查校验和：<code>ip_fast_csum(iph,iph-&gt;ihl)</code>。如果错误则跳转到对应错误处理。</li>
<li>检查IP包的总长度是否正确。</li>
<li>去掉填充字段：__pskb_trim(skb,len)。</li>
<li>由过滤器调用ip_rcv_finish函数，进一步处理数据包。<code>return NF_HOOK(PF_INET, NF_IP_PRE_ROUTING, skb, dev, NULL,ip_rcv_finish);</code></li>
</ol>
<h3 id="ip-rcv-finish-skb-net-ipv4-ip-input-c"><a href="#ip-rcv-finish-skb-net-ipv4-ip-input-c" class="headerlink" title="ip_rcv_finish(skb) net/ipv4/ip_input.c"></a>ip_rcv_finish(skb) <code>net/ipv4/ip_input.c</code></h3><ol>
<li>如果套接字缓冲区skb还未记录路由表项信息，则需要用ip_route_input查找路由表，为skb设置路由表项信息。</li>
<li>如果IP报头长度大于20字节，则报头携带了IP选项信息，调用函数skb_cow来确定skb是否被共享而可写入，以确保缓冲修改的安全性。<ol>
<li>函数<code>ip_options_compile(NULL,skb)</code>从数据包收集选项信息。</li>
<li>检查数据包是否设置了源路由选项(opt-&gt;srr)：<ol>
<li>调用<code>ip_options_rcv_srr(skb)</code>处理IP选项。</li>
</ol>
</li>
<li>通过接口dst_input确定对数据包的处理：递交给上层协议模块/转发。</li>
</ol>
</li>
</ol>
<h3 id="dst-input-skb-include-net-dst-h"><a href="#dst-input-skb-include-net-dst-h" class="headerlink" title="dst_input(skb) include/net/dst.h"></a>dst_input(skb) <code>include/net/dst.h</code></h3><p>该函数递交套接字缓冲区中的数据，具体去往何处由skb-&gt;dst-&gt;input指针确定。</p>
<p><strong>如果要转发数据包</strong>，则通过该指针调用函数<code>ip_forward</code>。</p>
<p><strong>如果要递交数据包</strong>，则通过该指针调用函数<code>ip_local_deliver</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Input packet from network to transport.  */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dst_input</span><span class="params">(struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 这里决定去向：</span></span><br><span class="line">		err = skb-&gt;dst-&gt;input(skb);</span><br><span class="line">        </span><br><span class="line">		<span class="keyword">if</span> (likely(err == <span class="number">0</span>))</span><br><span class="line">			<span class="keyword">return</span> err;</span><br><span class="line">		<span class="comment">/* Oh, Jamal... Seems, I will not forgive you this mess. :-) */</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(err != NET_XMIT_BYPASS))</span><br><span class="line">			<span class="keyword">return</span> err;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面先看交付本地的情况：ip_local_deliver。</p>
<h3 id="ip-local-deliver-skb-ip-input-c"><a href="#ip-local-deliver-skb-ip-input-c" class="headerlink" title="ip_local_deliver(skb) ip_input.c"></a>ip_local_deliver(skb) <code>ip_input.c</code></h3><p>重组IP包后存于skb，<code>ip_defrag(skb)</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*Deliver IP Packets to the higher protocol layers.*/</span> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ip_local_deliver</span><span class="params">(struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*Reassemble IP fragments.*/</span></span><br><span class="line">	<span class="comment">// 如果IP包在发送时被分成多个小片，则调用ip_defrag重组IP包</span></span><br><span class="line">	<span class="comment">// 完成重组的IP包被存放在套接字缓冲区中</span></span><br><span class="line">	<span class="keyword">if</span> (skb-&gt;nh.iph-&gt;frag_off &amp; htons(IP_MF|IP_OFFSET)) &#123;</span><br><span class="line">		skb = ip_defrag(skb);</span><br><span class="line">		<span class="keyword">if</span> (!skb)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 递交给ip_local_deliver_finish做进一步处理</span></span><br><span class="line">	<span class="keyword">return</span> NF_HOOK(PF_INET, NF_IP_LOCAL_IN, skb, skb-&gt;dev, <span class="literal">NULL</span>,ip_local_deliver_finish);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ip-local-deliver-finish-skb-ip-input-c"><a href="#ip-local-deliver-finish-skb-ip-input-c" class="headerlink" title="ip_local_deliver_finish(skb) ip_input.c"></a>ip_local_deliver_finish(skb) <code>ip_input.c</code></h3><p>该函数确定原始套接字列表raw_v4_htable中是否有接收数据包的套接字。</p>
<p>如果曾经注册过专门的原始套接字来接收某协议的数据包，则调用raw_v4_input接收该数据。</p>
<ol>
<li>得到IP报头长度ihl之后，调用<code>__skb_pull(skb,ihl)</code>把套接字缓冲区的数据从IP包取出。</li>
<li>得到IP报头封装的传输层协议类型值：<strong>protocol</strong>。</li>
<li>生成与协议变量protocol对应的查表索引值：<strong>hash</strong>。</li>
<li>判断与protocol对应的协议是否通过<strong>原始套接字</strong>接收数据，如果是，则返回对应原始套接字，并通过<code>raw_v4_input(skb,iph,hash)</code>来接收套接字缓冲区中的数据内容。</li>
<li>从表inet_protos[hash]得到管理protocol协议接受方法的struct net_protocol类型变量<code>inet_protos[hash]</code>，并保存在ippprot中；通过ipprot的handler指针调用上层协议的接收函数：<ol>
<li>protocol指示为UDP协议，则ipprot = &amp;udp_protocol；调用handler指向的函数<code>udp_rcv</code>；</li>
<li>protocol指示为ICMP协议，则ipprot = &amp;icmp_protocol;调用handler指向的函数<code>icmp_rcv</code>；</li>
</ol>
</li>
<li>如果上层模块没有接收缓冲区数据的套接字<code>(ipprot = inet_protos[hash]) == NULL</code>，则发送一个目的不可达的ICMP报文通知对方。</li>
</ol>
<p><strong>一些说明：</strong></p>
<p><strong>向raw_v4_htable表注册某原始套接字。</strong>如果创建了原始套接字，则hash函数把sk记录到raw_v4_htable表中。变量raw_prot管理SOCK_RAW类型套接字，它为hash指定了函数raw_v4_hash，该函数的功能就是把当前的套接字加入raw_v4_htable表中。</p>
<p><code>inet_init()</code><strong>向inet_protos表注册UDP协议</strong>——<code>struct net_protocol udp_protocol</code>，其中的成员变量handler指向<code>udp_rcv()</code>。</p>
<h2 id="IP包的转发"><a href="#IP包的转发" class="headerlink" title="IP包的转发"></a>IP包的转发</h2><h3 id="流程概述-1"><a href="#流程概述-1" class="headerlink" title="流程概述"></a>流程概述</h3><p><code>ip_rcv()→ ip_rcv_finish() →确定要转发dst_input() →ip_forward()→ip_forward_finish()→数据包交给ip_output()进入IP发送流程</code></p>
<p>这里从ip_forward()函数开始讲起。</p>
<h3 id="ip-forward-ip-forward-c"><a href="#ip-forward-ip-forward-c" class="headerlink" title="ip_forward() ip_forward.c"></a>ip_forward() <code>ip_forward.c</code></h3><ol>
<li>xfrm策略检查，skb的包类型检查。</li>
<li>如果设置了router_alert的选项，则必须调用<code>ip_call_ra_chain</code>处理数据包，<code>ip_call_ra_chain</code>会将数据包交给所有原始套接字。</li>
<li>获得IP报头iph，检查iph-&gt;ttl是否减为0，如果减为0，则<strong>goto too_many_hops</strong>，发送ICMP数据包报告数据包无效。</li>
<li>检查是否同时设置了严格路由标志和rt_uses_gateway标志。<ol>
<li>如果都使用了，则不能用严格路由选择，则goto sr_failed，发回一条“严格路由失败”的ICMP“目的不可达”消息。</li>
</ol>
</li>
<li>即将要修改数据包信息（ttl、checksum）则先拷贝一份skb。</li>
<li><strong>给iph-&gt;ttl字段减一。</strong></li>
<li>如果目的地址不可达，则通知发送数据的源端，<code>ip_rt_send_redirect(skb)</code>。</li>
<li><strong>假设没有NF_IP_FORWARD钩子，则调用<code>ip_forward_finish</code>完成转发的最后操作。</strong></li>
<li><strong>sr_failed</strong>：返回一个ICMP包，报告目的地不可达，<code>icmp_send(skb, ICMP_DEST_UNREACH, ICMP_SR_FAILED, 0);</code></li>
<li><strong>too_many_hops</strong>：返回一个ICMP包，报告数据包已失效，<code>icmp_send(skb, ICMP_TIME_EXCEEDED, ICMP_EXC_TTL, 0);</code></li>
</ol>
<h3 id="ip-forward-finish-ip-forward-c"><a href="#ip-forward-finish-ip-forward-c" class="headerlink" title="ip_forward_finish() ip_forward.c"></a>ip_forward_finish() <code>ip_forward.c</code></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ip_forward_finish</span><span class="params">(struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 更新统计信息</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ip_options</span> * <span class="title">opt</span>	= &amp;(<span class="title">IPCB</span>(<span class="title">skb</span>)-&gt;<span class="title">opt</span>);</span></span><br><span class="line"></span><br><span class="line">	IP_INC_STATS_BH(IPSTATS_MIB_OUTFORWDATAGRAMS);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查是否包含IP选项</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(opt-&gt;optlen))</span><br><span class="line">    <span class="comment">// 包含：</span></span><br><span class="line">		ip_forward_options(skb); </span><br><span class="line">    <span class="comment">// 否则：</span></span><br><span class="line">	<span class="keyword">return</span> dst_output(skb);<span class="comment">// 转入IP层的发送流程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>网络</tag>
        <tag>源码</tag>
        <tag>UDP</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux网络内核源码分析|传输层之UDP处理过程</title>
    <url>/2020/02/16/Linux%E7%BD%91%E7%BB%9C%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%BC%A0%E8%BE%93%E5%B1%82%E4%B9%8BUDP%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="关于UDP"><a href="#关于UDP" class="headerlink" title="关于UDP"></a>关于UDP</h1><h2 id="UDP数据包"><a href="#UDP数据包" class="headerlink" title="UDP数据包"></a>UDP数据包</h2><img src="/2020/02/16/Linux网络内核源码分析-传输层之UDP处理过程/UDP数据包.PNG">
<p>source/dest：长16位，取值范围1~65535。</p>
<p>len：有效负载和UDP数据报头的总长度，单位为字节。</p>
<h2 id="UDP初始化"><a href="#UDP初始化" class="headerlink" title="UDP初始化"></a>UDP初始化</h2><p>UDP和其他核心协议都是在启动阶段通过方法<code>inet_init()</code>来初始化的。</p>
<p>定义对象udp_protocol，用<code>inet_add_protocol()</code>添加。</p>
<p>内核还提供了UDP传输层操作集：<code>struct proto udp_prot{...}</code>，用<code>proto_register()</code>注册。</p>
<h1 id="UDP模块处理流程"><a href="#UDP模块处理流程" class="headerlink" title="UDP模块处理流程"></a>UDP模块处理流程</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>回顾套接字发送数据的流程，见<a href="https://xingkunz.github.io/2020/01/09/Linux网络内核源码分析-套接字之收发数据、监听、连接、绑定/#more">套接字之收发数据、监听、连接、绑定</a>：</p>
<p><code>send()|write()|sendto() → sys_send() → sys_sendto() → sock_sendmsg() → __sock_sendmsg() → sock-&gt;prot-&gt;sendmsg() → sk-&gt;sk_prot-&gt;sendmsg()</code></p>
<p>UDP采用SOCK_DGRAM类型的INET套接字，所以查询函数集后，最后两步具体调用的函数是：</p>
<p><code>→ inet_sendmsg() → udp_sendmsg()</code></p>
<p>自此，网络数据包从应用程序的发送函数开始，已经过套接字接口，应用程序把应用层数据内容置入内核，并通知内核的<strong>UDP协议模块</strong>继续发送数据。下面主要关注UDP协议模块中的处理流程，直到UDP协议模块将数据包交给IP层协议模块。</p>
<img src="/2020/02/16/Linux网络内核源码分析-传输层之UDP处理过程/UDP模块处理流程.png" title="UDP模块处理流程">
<p>如果在应用层调用发送函数，若采用SOCK_DGRAM套接字，会触发内核<code>udp_sendmsg</code>调用，查找路由信息后，调用<code>ip_append_data</code>对数据做分片处理，然后调用<code>udp_push_pending_frames</code>进行UDP包封装，并把数据包交给IP层处理。</p>
<p>如果在应用层调用接收函数，IP层取出数据内容后，函数<code>ip_local_deliver_finish</code>会调用UDP模块的<code>udp_rcv</code>函数。数据包会被加入套接字队列，再由函数<code>udp_recvmsg</code>取出，并通知应用程序函数读取数据。</p>
<h2 id="UDP包的发送"><a href="#UDP包的发送" class="headerlink" title="UDP包的发送"></a>UDP包的发送</h2><p>应用层采用SOCK_DGRAM套接字发送数据，会触发内核<code>udp_sendmsg</code>调用。</p>
<h3 id="udp-sendmsg-iocb-sk-msg-len-udp-c"><a href="#udp-sendmsg-iocb-sk-msg-len-udp-c" class="headerlink" title="udp_sendmsg(iocb, sk, msg, len) udp.c"></a>udp_sendmsg(iocb, sk, msg, len) <code>udp.c</code></h3><ol>
<li>设置corkreq：用于指出是否应该使用缓冲区机制，如果没有则数据包立即被发送，如果有则数据包会交给<code>udp_sendmsg()</code>累积，直到取消该选项——最后一个数据包到达。</li>
<li>检查长度len是否越界。</li>
<li>检查msg中是否有MSG_OOB（指定flag为MSG_MORE时，corkreq=1，等于使用了缓冲区机制）。</li>
<li>通过检查msg-&gt;msg_name字段，判断目的地址是否合法：<ol>
<li>目的地址不为空：检查是否目的地址是否合法，协议族是否正确，有错误则return -EINVAL;</li>
<li>目的地址为空：若套接字处于TCP_ESTABLISHED状态（套接字已连接）仍认为目的地址合法，允许继续传送数据；若套接字不处于TCP_ESTABLISHED状态，则return -EDESTADDRREQ;</li>
</ol>
</li>
<li>检查msg-&gt;msg_controllen，即：如果是控制报文（不为0），则通过<code>ip_cmsg_send()</code>处理控制报文，该方法分析指定的msghdr对象，并创建一个icmp_cookie对象（包含可供处理数据包时使用的信息）。</li>
<li>确定是否需要路由信息，是否广播。</li>
<li>若套接字已连接，则不需要查询路由，从套接字管理信息中返回路由表信息，并记录到rtable中。</li>
<li>若套接字无路由信息(rt==NULL)，则调用<code>ip_route_output_flow()</code>查询路由表。</li>
<li>cork the socket: inet-&gt;cork.fl的赋值。</li>
<li><code>ip_append_data</code>()：对UDP数据包进行分片处理，为IP层分片处理做好准备<ol>
<li>若设置了corkreq，则需要调用<code>lock_sock()</code>获取套接字锁，之后再发送数据包，<code>ip_append_data()</code>会将数据加入缓冲区，不立即传输，之后第调用<code>udp_push_pending_frames(sk, up)</code>来完成传输。</li>
<li>出错则：<code>udp_flush_pending_frames(sk)→ip_flush_pending_frames()</code>，清空所有等待传输的SKB;</li>
<li>没有出错且corkreq=0(不使用缓冲机制)则：<code>udp_push_pending_frames(sk, up)</code>; </li>
</ol>
</li>
<li>一些结束处理。标签out和do_confirm。</li>
</ol>
<h3 id="ip-append-data-ip-output-c"><a href="#ip-append-data-ip-output-c" class="headerlink" title="ip_append_data ip_output.c"></a>ip_append_data <code>ip_output.c</code></h3><p>创建套接字缓冲区sk_buff，为IP层数据分片做好准备；该函数根据路由查询得到的接口MTU，把超过MTU长度的数据分片保存在多个套接字缓冲区中，并插入套接字的发送队列sk_write_queue中（对于较大的数据包，该函数可能循环多次）。</p>
<p>具体过程：</p>
<ol>
<li>一些变量的声明。其中：<ol>
<li>从sk结构中获取inet结构：<code>struct inet_opt *inet = inet_sk(sk)</code>；inet结构保存套接字选项，inet-&gt;cork成员存储了与分片有关的控制信息。</li>
</ol>
</li>
<li>判断套接字发送队列sk-&gt;sk_write_queue是否为空。<ol>
<li>队列为空，则对inet-&gt;cork初始化，为分片做准备；<ol>
<li>ip选项不为空，则获取一些分片用的信息设置inet-&gt;cork；</li>
<li>初始化分片位置信息：设置sk的指针指向分片首地址、下一分片的存放位置；</li>
</ol>
</li>
<li>队列不为空/不是第一个分片，则套接字缓冲区的data内容中没有头部格式信息。</li>
</ol>
</li>
<li>从路由表项中得到网络设备的硬件头部信息。</li>
<li>分片首部长度：${fragheaderlen}={ip头部}+{ip选项长度（如果有）}$；获取分片最大长度（maxfraglen）。</li>
<li>累计分片数据的总长度，由inet-&gt;cork.length记录。</li>
<li>如果是空队列/是第一个分片，需要分配一个新的套接字缓冲区。</li>
<li>把尚未插入队列的新数据插入到套接字发送队列中。若$length&gt;0$则说明数据还有剩余，需要继续分片并插入队列。<ol>
<li>如果当前套接字缓冲区中没有空间装剩下的数据，则要分配新套接字缓冲区给剩下的数据；<ol>
<li>分片长度：$fraglen={fragheaderlen}+{数据长度}$；</li>
<li>为最后一个碎片分配更多空间；</li>
<li>分配套接字缓冲区；</li>
<li>设置IP数据包的校验和模式（csummode），并初始化校验和（csum）；</li>
<li>在套接字缓冲区中预留容纳硬件头头部的空间<code>skb_reserve</code>；</li>
<li>为套接字缓冲区设置数据存放的起始位置：设置skb；</li>
<li>计算实际需要复制的数据长度（copy），把数据复制到套接字缓冲区中；</li>
<li>计算分片偏移位置，计算尚未分配套接字缓冲区的数据长度；</li>
<li>把已分配得到的套接字缓冲区插入套接字发送队列中。</li>
</ol>
</li>
<li>判断网络设备是否设置了scatter/gather，如果有，则按照scatter/gather设置分片处理。</li>
</ol>
</li>
</ol>
<h3 id="udp-push-pending-frames-sk-up-udp-c"><a href="#udp-push-pending-frames-sk-up-udp-c" class="headerlink" title="udp_push_pending_frames(sk,*up) udp.c"></a>udp_push_pending_frames(sk,*up) <code>udp.c</code></h3><p>传入参数*up为struct udp_opt型。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">udp_opt</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span>		pending;<span class="comment">// Any pending frames ?</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>	corkflag;<span class="comment">// Cork is required</span></span><br><span class="line">  	__u16	encap_type;<span class="comment">// Is this an Encapsulation socket?</span></span><br><span class="line">	<span class="comment">// Following member retains the infomation to create a UDP header</span></span><br><span class="line">	<span class="comment">// when the socket is uncorked.</span></span><br><span class="line">	__u16	len;<span class="comment">// total length of pending frames</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>该函数具体执行：</p>
<ol>
<li>一些变量的声明。其中：<ol>
<li>从sk结构中获取inet结构：<code>struct inet_opt *inet = inet_sk(sk)</code>；inet结构保存套接字选项，inet-&gt;cork成员存储了与分片有关的控制信息。</li>
<li>声明一个struct sk_buff *skb用于存套接字队列中的一个套接字缓冲区。</li>
<li>声明一个struct udphdr *uh用于保存udp头部信息。 </li>
</ol>
</li>
<li>从套接字发送队列（&amp;sk-&gt;sk_write_queue）中得到一个套接字缓冲区，<code>skb_peek</code>。</li>
<li>为数据包设置udp头部信息：源端口、目的端口、长度等，存于uh。</li>
<li>如果不需要校验和计算，则直接去发送该数据包<code>goto send</code>。</li>
<li>校验和处理。</li>
<li><strong>send</strong>：准备IP协议处理，<code>ip_push_pending_frames(sk)</code>。</li>
</ol>
<h2 id="UDP包的接收"><a href="#UDP包的接收" class="headerlink" title="UDP包的接收"></a>UDP包的接收</h2><p>发现接收了一个UDP包，IP层协议调用udp_rcv把数据包递交到UDP协议模块。</p>
<p>通过调用udp_queue_rcv_skb和sock_queue_rcv_skb，UDP协议模块把数据包插入套接字的接收队列中，等待udp_recvmsg从队列中取出数据包，递交到应用程序。</p>
<h3 id="udp-rcv-skb-udp-c"><a href="#udp-rcv-skb-udp-c" class="headerlink" title="udp_rcv(skb) udp.c"></a>udp_rcv(skb) <code>udp.c</code></h3><p>被注册为接收UDP数据包的方法。</p>
<p>UDP初始化时，内核通过struct net_protocol udp_protocol注册接收UDP数据包的方法。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_protocol</span> <span class="title">udp_protocol</span> = &#123;</span></span><br><span class="line">	.handler = udp_rcv,</span><br></pre></td></tr></table></figure>
<p>udp_rcv函数具体内容：</p>
<ol>
<li>判断套接字缓冲区中是否存在一个UDP头部长度的存储区。<ol>
<li>如果不存在则goto no_header处理。</li>
</ol>
</li>
<li>获取UDP包的起始位置uh，获取UDP包的长度ulen。</li>
<li>得到UDP数据包的长度，<code>pskb_trim()</code>。</li>
<li>是否组播？是：<code>udp_v4_mcast_deliver()</code>；否：继续。</li>
<li>根据套接字信息（源IP地址、源端口、目的IP地址、目的端口），查找端口上是否有一个打开的套接字？<code>sk=udp_v4_lookup()</code>。<ol>
<li>如果还有，则把套接字缓冲区插入套接字sk的接收队列中，<code>udp_queue_rcv_skb()</code>，<strong>返回</strong>。</li>
<li>sk==NULL：继续。</li>
</ol>
</li>
<li>检查校验和，校验和正确则继续。如果校验和错误，则丢掉该数据包，<code>goto csum_error</code>。</li>
<li>返回一个ICMP包，通知对方目的地/端口不可达，<code>icmp_send()</code>。</li>
<li>丢弃数据包。</li>
</ol>
<blockquote>
<p>参考：《Linux网络内核分析与开发》，肖宇峰、李昕、时岩编著。</p>
</blockquote>
<h3 id="udp-queue-rcv-skb-sk-skb-udp-c"><a href="#udp-queue-rcv-skb-sk-skb-udp-c" class="headerlink" title="udp_queue_rcv_skb(sk,skb) udp.c"></a>udp_queue_rcv_skb(sk,skb) <code>udp.c</code></h3><p>被<code>udp_rcv</code>所调用，通过<code>sock_queue_rcv_skb</code>把收到的套接字缓冲区skb插入套接字sk的接收队列中。</p>
<h4 id="IPsec与XFRM框架"><a href="#IPsec与XFRM框架" class="headerlink" title="IPsec与XFRM框架"></a>IPsec与XFRM框架</h4><p>涉及到IPsec——Internet协议安全子系统：是一组协议，是大多数IPVPN技术的标准配置。这组协议对通信会话中的每个数据包进行身份验证和加密，以确保IP流量的安全。</p>
<p>IPsec是由XFRM框架实现的，XFRM读作’transfrom’。XFRM框架是独立于协议簇的，旨在提供适用于生产环境的IPv6和IPsec协议栈。</p>
<p>XFRM策略（xfrm_policy）和XFRM状态（xfrm_state）是XFRM框架中的基本数据结构。</p>
<p>XFRM策略：告诉IPsec是否要对特定流进行处理的规则，策略包含一个选择器（xfrm_selector），用于指定要将策略应用于哪些流。</p>
<p>XFRM状态：表示IPsec安全关联，包含加密密钥、标志、请求ID、统计信息、重放参数等信息。内核将IPsec安全关联存储在安全关联数据库中。</p>
<h4 id="函数具体内容"><a href="#函数具体内容" class="headerlink" title="函数具体内容"></a>函数具体内容</h4><ol>
<li>XFRM安全策略检查，<code>xfrm4_policy_check(sk,XFRM_POLICY_IN,skb)</code>。</li>
<li>对IPsec封装包进行分析处理。</li>
<li>检查sk、skb，如果需要校验，则计算校验和。</li>
<li>调用函数<code>sock_queue_rcv_skb(sk,skb)</code>将套接字缓冲区skb插入套接字sk的接收队列中。</li>
</ol>
<h3 id="sock-queue-rcv-skb-sk-skb-sock-h"><a href="#sock-queue-rcv-skb-sk-skb-sock-h" class="headerlink" title="sock_queue_rcv_skb(sk,skb) sock.h"></a>sock_queue_rcv_skb(sk,skb) <code>sock.h</code></h3><p>对套接字缓冲区skb做简单处理后，函数<code>sock_queue_rcv_skb</code>把套接字缓冲区插入套接字接收队列<code>sk-&gt;sk_receive_queue</code>的尾部。</p>
<ol>
<li>套接字的包过滤处理，<code>sk_filter()</code>。出错则结束函数，返回错误信息。</li>
<li>设置套接字缓冲区skb的一些数据<ol>
<li>skb-&gt;dev置空；</li>
<li>skb-&gt;sk指针指向当前套接字结构sk，<code>skb_set_owner_r(skb,sk)</code>。</li>
</ol>
</li>
<li>插入套接字接收队列的尾部，<code>skb_queue_tail(&amp;sk-&gt;sk_receive_queue, skb);</code>。</li>
<li>通知被阻塞的操作：套接字接收队列中已有数据就绪，<code>sock_flag()</code>。</li>
</ol>
<h3 id="udp-recvmsg-udp-c"><a href="#udp-recvmsg-udp-c" class="headerlink" title="udp_recvmsg() udp.c"></a>udp_recvmsg() <code>udp.c</code></h3><p>应用程序通过套接字调用接收函数时，会调用内核函数<code>udp_recvmsg()</code>。该函数从套接字队列中取出数据，并通过struct msghdr结构把其中的数据和地址信息复制给用户程序。</p>
<ol>
<li>检查地址长度；检查队列中是否有错误信息。</li>
<li>从套接字sk的接收队列中取出套接字缓冲区skb，<code>skb_recv_datagram()</code></li>
<li>准备复制数据：需要复制的数据（copied）不包括UDP头部；如果缓冲区长度不够（copied&gt;len），则设置缓冲区长度，并作截断标志。</li>
<li>校验判断：<ol>
<li>如果不需要校验（skb-&gt;ip_summed==CHECKSUM_UNNECESSRY），则把套接字缓冲区skb数据复制到msg-&gt;msg_iov结构中，以便应用程序从接收缓冲区中读取数据，<code>skb_copy_datagram_iovec()</code>。</li>
<li>如果需要校验，则先校验，再把套接字缓冲区skb数据复制到msg-&gt;msg_iov结构，<code>skb_copy_datagram_iovec()</code>。</li>
<li>其他情况：复制套接字缓冲区的内容并进行校验，<code>skb_copy_and_csum_datagram_iovec()</code>。</li>
</ol>
</li>
<li>记录接收时间，<code>sock_recv_timestamp(msg,sk,skb)</code>。</li>
<li>复制地址信息：sin &lt;- skb。</li>
<li>处理IP选项，<code>ip_cmsg_recv(msg,skb)</code>。</li>
<li>如果用户程序接收数据采用MSG_PEEK标志，则读出数据，但不删除套接字队列中的缓冲。</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>网络</tag>
        <tag>源码</tag>
        <tag>UDP</tag>
      </tags>
  </entry>
  <entry>
    <title>计科学生找工作的简洁指南</title>
    <url>/2020/02/07/%E8%AE%A1%E7%A7%91%E5%AD%A6%E7%94%9F%E6%89%BE%E5%B7%A5%E4%BD%9C%E7%9A%84%E7%AE%80%E6%B4%81%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h2 id="做简历"><a href="#做简历" class="headerlink" title="做简历"></a>做简历</h2><p><strong>简历信息的筛选原则（建议）</strong>：挑重点写，设置在简历上的内容都是为了体现自己的品质和能力。</p>
<p><strong>措辞方面</strong>：表达简洁、清晰、诚实，尽量规避使用”精通”和”熟练”，重点可加粗。</p>
<p><strong>内容</strong>：</p>
<ul>
<li>有<strong>目标职位相关、专业的实习经历</strong>最好，清楚地表达在实习中所做的成果和收获；</li>
<li>如果缺乏实习经历，可以诚实地写自己的<strong>课程项目</strong>，并且要对自己写的东西足够了解，涉及的技术需要复习复习；</li>
<li>此外，如果有<strong>值得讲的校园工作经历（例如：学生会工作、社团工作）</strong>，可以适当罗列，以此突出良好性格和其他通用能力。</li>
</ul>
<p><strong>简历模板来源</strong>：</p>
<ul>
<li>知乎上讲解如何写简历的帖子中往往有简历模板的网盘链接、在线制作简历的网站链接；</li>
<li>网站推荐：<strong><a href="http://dazhao100.com/">大招一百</a></strong>，<strong><a href="https://www.wondercv.com/">超级简历</a></strong>等。线上制作的简历可以导出，方便频繁修改以及换模板。</li>
</ul>
<h2 id="复习和准备"><a href="#复习和准备" class="headerlink" title="复习和准备"></a>复习和准备</h2><p><strong>准备范围</strong>：以常用算法、数据结构、操作系统、计算机网络以及自己所擅长的语言相关知识为基础，根据自己的工作意向调整复习重点。</p>
<p><strong>准备前</strong>：</p>
<ul>
<li>确定大致的工作意向，考虑专业方面的兴趣、自己的性格和能力谱系；</li>
<li>看<strong>招聘官网</strong>的要求，看<strong>面经</strong>，确定自己的复习范围，有的放矢。</li>
</ul>
<p><strong>具体的准备</strong>：</p>
<ul>
<li>熟悉自己简历上提到的内容；</li>
<li>面经来源：<strong>看准app</strong>，知乎，CSDN；</li>
<li>在<strong><a href="https://www.nowcoder.com/contestRoom">牛客网</a></strong>刷题（其中选择题、判断题为主）；</li>
<li>对于需要机试和需要当场写代码的面试，可以在<strong><a href="https://leetcode-cn.com/">leetcode</a></strong>刷算法题。这里推荐<a href="https://leetcode-cn.com/explore/interview/card/top-interview-quesitons-in-2018/">leetcode的算法面试题汇总</a>以及<a href="https://blog.csdn.net/Sunshine8430/article/details/88627517">对应的一个含部分答案的博客</a>；</li>
<li><a href="https://visualgo.net/zh">一个数据结构和算法可视化网站</a>。</li>
</ul>
<h2 id="网申和面试"><a href="#网申和面试" class="headerlink" title="网申和面试"></a>网申和面试</h2><p><strong>就业信息来源</strong>：</p>
<ul>
<li>学校就业公众号、各企业招聘微信公众号；</li>
<li><a href="http://www.yingjiesheng.com/">应届生求职网</a>、<a href="https://landing.zhaopin.com/register?utm_source=360PC&amp;utm_medium=CPC&amp;utm_term=163190&amp;utm_content=qg&amp;utm_campaign=ty&amp;sid=121122526">智联招聘</a>（注册智联招聘后会有频繁的短信通知，根据自己需求取消订阅）。</li>
</ul>
<p><strong>网申策略（建议）</strong>：尽量在自己应付范围内海投，重点准备其中几个。</p>
<p><strong>面试准备</strong>：</p>
<ul>
<li>准备一段2~3分钟的自我介绍，要与简历配合好，多多练习；</li>
<li>一次面试建议打印3份简历，面试后要复盘，常常修改自己的简历；</li>
<li>表达要自信、诚实。</li>
</ul>
<p><strong>关于群面的一些坑</strong>：</p>
<p>部分岗位会需要群面，可以参考目标职位的面经，其中有各种各样的群面经验分享。下面是一些通用的无领导小组讨论的注意事项：</p>
<ul>
<li>自我介绍的时候不要刻意规避自己的缺点，也不要硬把缺点讲成优点；</li>
<li>认真聆听别人的介绍，记住尽量多的人的“名字+关键标签”；</li>
<li>尽量挑适合自己的组内角色，比如：思路清晰（或者字好看、写字快）的同学可以考虑当记录员；思维活跃的同学可以积极参与讨论；有组织能力可以争取一下组长的职位；</li>
<li><strong>讨论时</strong>不要抢做别人的工作，尽量做好自己的工作并稍微加强自己的存在感；</li>
<li><strong>讨论后</strong>的发言阶段不要临时加观点来补充别人的发言；讨论一旦结束，要对自己的表现感到自信，不能自我否定。</li>
</ul>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo|解决博客渲染公式的问题</title>
    <url>/2020/01/13/hexo-%E8%A7%A3%E5%86%B3%E5%8D%9A%E5%AE%A2%E6%B8%B2%E6%9F%93%E5%85%AC%E5%BC%8F%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>常用的Markdown编辑器都会集成<a href="https://link.jianshu.com/?t=https%3A%2F%2Fwww.mathjax.org%2F">Mathjax</a>，用来渲染文档中的类Latex格式书写的数学公式。</p>
<h2 id="更换Hexo的markdown渲染引擎"><a href="#更换Hexo的markdown渲染引擎" class="headerlink" title="更换Hexo的markdown渲染引擎"></a>更换Hexo的markdown渲染引擎</h2><p>在<code>博客目录</code>下执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure>
<h2 id="在主题配置中开启mathjax开关"><a href="#在主题配置中开启mathjax开关" class="headerlink" title="在主题配置中开启mathjax开关"></a>在主题配置中开启mathjax开关</h2><p>在<code>博客目录/themes/你用的主题/_config.yml</code>文件中，开启math支持，enable置为true：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Math Formulas Render Support</span></span><br><span class="line"><span class="attr">math:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 默认加载mathjax,katex渲染</span></span><br><span class="line"><span class="attr">  per_page:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 此选项开启表示每页博客是否使用mathjax是单独指定的。</span></span><br><span class="line">  <span class="comment"># 单独指定需要公式渲染的博客，可以提高平均的加载速率。</span></span><br></pre></td></tr></table></figure>
<p>开启mathjax支持，enable置为true：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># hexo-renderer-pandoc (or hexo-renderer-kramed) required for full MathJax support.</span></span><br><span class="line"><span class="attr">mathjax:</span></span><br><span class="line"><span class="attr">   enable:</span> <span class="literal">true</span></span><br><span class="line">   <span class="comment"># See: https://mhchem.github.io/MathJax-mhchem/</span></span><br><span class="line"><span class="attr">   mhchem:</span> <span class="literal">false</span></span><br><span class="line">   <span class="comment"># 这个化学公式的语法支持，读者可选。 $\ce&#123;公式&#125;$</span></span><br><span class="line">   <span class="comment"># a third-party extension for MathJax</span></span><br></pre></td></tr></table></figure>
<h2 id="开启行内公式加载"><a href="#开启行内公式加载" class="headerlink" title="开启行内公式加载"></a>开启行内公式加载</h2><p>以上内容仅支持块状公式渲染，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$公式$$</span><br></pre></td></tr></table></figure>
<p>现在我们开启行内公式渲染,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对于变量$v_1$，如何如何......</span><br></pre></td></tr></table></figure>
<p>在<code>博客目录\node_modules\kramed\lib\rules\inline.js</code>中做如下变动：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</span></span><br><span class="line">em: <span class="regexp">/^\*((?:\*\*|[\s\S])+?)\*(?!\*)/</span>,</span><br></pre></td></tr></table></figure>
<p>即可。</p>
<h2 id="写博客时开启mathjax"><a href="#写博客时开启mathjax" class="headerlink" title="写博客时开启mathjax"></a>写博客时开启mathjax</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: 符号执行测试|概述</span><br><span class="line">date: 2020-01-12 17:51:54</span><br><span class="line">mathjax: true</span><br><span class="line">tags:</span><br><span class="line">- 软件测试</span><br><span class="line">- 符号执行</span><br></pre></td></tr></table></figure>
<p>写一篇需要打公式的博客，则在开头front-matter，指定<code>mathjax:true</code>。此选项与title、date、tags同级。如此指定后，该篇博客可以成功加载公式。</p>
<h2 id="编辑公式参考语法"><a href="#编辑公式参考语法" class="headerlink" title="编辑公式参考语法"></a>编辑公式参考语法</h2><a href="http://www.mohu.org/info/lshort-cn.pdf">常用数学符号的 LaTeX 表示方法</a>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>符号执行测试|概述</title>
    <url>/2020/01/12/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%E6%B5%8B%E8%AF%95-%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<blockquote>
<p>Reference: Symbolic Execution for Software Testing: Three Decades Later</p>
</blockquote>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>符号执行是一种可生成<strong>高覆盖测试用例</strong>、在复杂程序中寻找<strong>深层错误</strong>的有效技术；是一种流行的<strong>程序分析技术</strong>。</p>
<p>使用符号执行分析一个程序时，该程序会使用符号值作为输入，而非一般执行程序时使用的具体值。在达到目标代码时，分析器可以得到相应的路径约束，然后通过约束求解器来得到可以触发目标代码的具体值。</p>
<h2 id="目标及优势"><a href="#目标及优势" class="headerlink" title="目标及优势"></a>目标及优势</h2><p>在给定时间里，探索尽量多的、不同的程序路径（program path）。</p>
<ol>
<li>生成一个具体输入的集合；（符号执行的主要优势之一）</li>
<li>检查是否存在错误：断言违规、未捕获的异常、安全漏洞和内存损坏。</li>
</ol>
<p>其中，生成具体输入集合的优势所在：</p>
<ul>
<li>测试用例角度：允许创建高覆盖率的测试套件；</li>
<li>查找bug角度：针对bug提供触发此bug的输入，用于验证和debug。</li>
</ul>
<p>另外，在给定程序路径中寻找错误时，符号执行比传统的动态执行技术更强大，传统动态执行技术的表现则要看那些触发错误的具体输入的可用性。</p>
<p>最后，与某些其他程序分析技术不同，符号执行既可以找出“缓冲区溢出”这样的一般性错误，也可以引出更高级的程序属性，例如“复杂的程序断言”。</p>
<h1 id="传统符号执行"><a href="#传统符号执行" class="headerlink" title="传统符号执行"></a>传统符号执行</h1><h2 id="符号执行的核心思想"><a href="#符号执行的核心思想" class="headerlink" title="符号执行的核心思想"></a>符号执行的核心思想</h2><ul>
<li>输入：用符号值(symbolic values)来表征而不是具体值(concrete data values)；</li>
<li>程序变量：根据输入符号值表征成符号表达式(symbolic expressions)；</li>
<li>输出：根据程序计算出的函数表达式:</li>
</ul>
<script type="math/tex; mode=display">
function(input)</script><h2 id="执行路径与执行树"><a href="#执行路径与执行树" class="headerlink" title="执行路径与执行树"></a>执行路径与执行树</h2><p>在软件测试中，符号执行用于生成执行路径的输出；符号执行可以同时探索程序在不同输入下可能采用的多种路径。</p>
<ul>
<li><p>（一条）<strong>执行路径</strong> (execution path) ：由true/false组成的一个序列，</p>
<script type="math/tex; mode=display">
seq=\{p1,p2,p3,...\}</script><p>如果$ p_i=true $，则说明在此路径中第$i$个条件语句取$true$值，走$then$分支。</p>
</li>
<li><p><strong>执行树 </strong>(execution tree) ：一个程序的所有执行路径用树形结构表示。</p>
</li>
</ul>
<p>举例:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">twice</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testme</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    z=twice(y);</span><br><span class="line">    <span class="keyword">if</span>(z==x)&#123; <span class="comment">//condition statement 1</span></span><br><span class="line">        <span class="keyword">if</span>(x&gt;y+<span class="number">10</span>)&#123; <span class="comment">//condition statement 2</span></span><br><span class="line">            ERROR; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    x=sym.input();</span><br><span class="line">    y=sym_input();</span><br><span class="line">    testme(x,y);</span><br><span class="line">    <span class="keyword">return</span> ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段程序由两个条件语句分流成三条分支，设计如下三个输入：</p>
<script type="math/tex; mode=display">
\{x=0,y=1\},\{x=2,y=1\},\{x=30,y=15\}</script><p>可覆盖到三条执行路径，即：</p>
<script type="math/tex; mode=display">
\{ true,true \},\{ true,false \},\{ false,* \}</script><p>三条执行路径形成一个执行树，</p>
<pre class="mermaid">graph TD
    A[2*y equals x] -->|true| B[x greater than y+10]
    A -->|false| C(x=0,y=1)
    B -->|true| D(x=30,y=15)
    B -->|false| E(x=2,y=1)</pre>

<h2 id="符号状态和符号路径约束"><a href="#符号状态和符号路径约束" class="headerlink" title="符号状态和符号路径约束"></a>符号状态和符号路径约束</h2><ul>
<li><p><strong>符号状态</strong> $\sigma$  (symbolic state) :符号执行维护一个符号状态，将变量映射成符号表达式。</p>
</li>
<li><p><strong>符号路径约束</strong> $PC$  (symbolic path constraint) ：一个无修饰的、一阶逻辑的符号表达式公式。（a quantifier-free first-order formula over symbolic expression）</p>
<blockquote>
<p><a href="#补充概念解释">参看：补充概念解释</a></p>
</blockquote>
</li>
</ul>
<h3 id="分析普通程序"><a href="#分析普通程序" class="headerlink" title="分析普通程序"></a>分析普通程序</h3><p>符号执行开始时，$\sigma$被初始化为空映射集合$\sigma =\phi，$PC$被初始化为$true$，$\sigma$和PC会在符号执行过程中不断更新。</p>
<p>每当程序给一个变量获取新值，就将$var\rightarrow s$加入$\sigma ={…}$中，s是一个新的符号值；每当程序给一个变量赋新值，就更新$\sigma$中该变量所映射的符号值。</p>
<p>每当经过一个条件语句$e$，$PC$会被更新为$PC\wedge \sigma(e)$，并走”then”分支；同时生成一个新的$PC’$并初始化为$PC\wedge \neg{\sigma(e)}$，并走”else”分支。</p>
<p>每当经过一个$PC$/ $PC’$允许的赋值语句，$PC$/ $PC’$会保持不变继续走，各自维护和更新自己的$\sigma$；</p>
<p>在沿着一条执行路径的符号执行结束时，PC使用<strong>约束求解器</strong> (constraint solver) 来生成具体的输入值。如果程序在这些具体的输入值上执行，它将采取与符号执行完全相同的路径，并以相同的方式终止。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">twice</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testme</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    z=twice(y);</span><br><span class="line">    <span class="comment">/*sigma=&#123;x-&gt;x0,y-&gt;y0,z-&gt;2y0&#125;*/</span> <span class="comment">//z获取到符号值</span></span><br><span class="line">    <span class="keyword">if</span>(z==x)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;y+<span class="number">10</span>)&#123;<span class="comment">//PC: (x0=2y0) and (x0&gt;y0+10)</span></span><br><span class="line">            ERROR; </span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            sigma=&#123;</span></span><br><span class="line"><span class="comment">            	x-&gt;x0,</span></span><br><span class="line"><span class="comment">            	y-&gt;y0,</span></span><br><span class="line"><span class="comment">            	x=2y0,</span></span><br><span class="line"><span class="comment">            	x0 &gt; y0+10</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        &#125;<span class="comment">//PC': else:(x0=2y0) and (x0&lt;=y0+10)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    start: sigma=&#123;&#125;,PC=true</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    x=sym.input();</span><br><span class="line">    y=sym_input();</span><br><span class="line">    <span class="comment">/*sigma=&#123;x-&gt;x0,y-&gt;y0&#125;*/</span> <span class="comment">//x0,y0是两个初始化的无约束的符号值。</span></span><br><span class="line">    testme(x,y);</span><br><span class="line">    <span class="keyword">return</span> ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分析循环程序"><a href="#分析循环程序" class="headerlink" title="分析循环程序"></a>分析循环程序</h3><p>当代码中包含循环和递归时，如果终止条件是符号的话，那么符号执行会产生无限数量的执行路径。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testme_inf</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> N=sym_input();</span><br><span class="line">    <span class="keyword">while</span>(N&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        sum = sum+N;</span><br><span class="line">        N=sym_input();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此种情况可能有无数条执行路径，执行路径要么有无限长的<code>true</code>；要么有无数个<code>true</code>后以一个<code>false</code>跳出循环并结束，则此条路径的$PC$和符号状态$\sigma$如下：</p>
<script type="math/tex; mode=display">
PC = \big( \bigwedge_{i\in[1,n]}{N_i > 0} \big)\wedge(N_{n+1}\leq0)</script><script type="math/tex; mode=display">
\sigma= \{N \to N_{n+1},sum \to \sum_{i \in [1,n]}{N_i}\}</script><h3 id="传统符号执行的缺点"><a href="#传统符号执行的缺点" class="headerlink" title="传统符号执行的缺点"></a>传统符号执行的缺点</h3><p>如果符号路径约束$PC$不可解或不能被高效地解决，则不能为程序生成input。</p>
<h3 id="补充概念解释"><a href="#补充概念解释" class="headerlink" title="补充概念解释"></a>补充概念解释</h3><ul>
<li><p>一阶逻辑 first-order logic ：逻辑函数的参数可以是变量，但不能是函数。这种语言的语法(Syntax)由字母系统(Alphabet)和构造法则(formation rules)组成。</p>
</li>
<li><p>无修饰公式 quantifier-free formulas ：由谓词符号、等式和逻辑运算符号组成的公式。比如：$p(x)$。</p>
</li>
<li><p>构造法则 formation rules ：</p>
<ul>
<li>术语 terms ：包括变量、函数。</li>
<li>公式 formulas：包括修饰符(quantifier)、谓词符号、等式、逻辑运算符号。</li>
</ul>
</li>
</ul>
<blockquote>
<p>参考：<a href="https://www.cnblogs.com/steven-yang/p/7104068.html">可满足性模块理论(SMT)基础</a></p>
</blockquote>
<h1 id="现代符号执行"><a href="#现代符号执行" class="headerlink" title="现代符号执行"></a>现代符号执行</h1><p>现代符号执行技术的特点是同时执行具体执行和符号执行。以下技术可以统称为”动态符号执行“。</p>
<h2 id="混合执行测试-concolic-testing"><a href="#混合执行测试-concolic-testing" class="headerlink" title="混合执行测试(concolic testing)"></a>混合执行测试(concolic testing)</h2><p>当给定若干个具体的输入时，混合执行测试动态地执行符号执行。</p>
<p>混合执行测试维护两个状态：</p>
<ol>
<li>具体状态（concrete state）：映射{所有变量$\rightarrow$具体值}</li>
<li>符号状态（symbolic state）：只映射有非具体值的变量。</li>
</ol>
<p>混合执行测试需要一个具体的初始值，因而使用一些既定的、随机的输入来执行程序。执行过程中，从程序中的各条件语句收集符号约束，之后用约束求解器推断之前输入值的变化，以此来控制程序的下一段可选择路径的执行。</p>
<p>混合测试使用一些既定的、随机的输入来执行程序，从程序中的各条件语句收集符号约束，之后用约束求解器推断之前输入值的变化，以此来控制程序的下一段可选择路径的执行。</p>
<p>这个过程是系统地或启发性地重复的，直到所有的执行路径都被探索，用户定义的覆盖率标准被满足，或者时间预算过期。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">twice</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testme</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    z=twice(y);</span><br><span class="line">    <span class="keyword">if</span>(z==x)&#123;<span class="comment">/*PC=(2*y0=x0) //x=2,y=1</span></span><br><span class="line"><span class="comment">        S3:&#123;x=2,y=1&#125; takes this path, </span></span><br><span class="line"><span class="comment">        different from prev(S2)</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span>(x&gt;y+<span class="number">10</span>)&#123;<span class="comment">/*PC=(2*y0==x0)^(x0&gt;y0+10) //x=30,7=15</span></span><br><span class="line"><span class="comment">        	S5:&#123;x=30,7=50&#125; takes this path, </span></span><br><span class="line"><span class="comment">        	different from prev(S4)</span></span><br><span class="line"><span class="comment">        	*/</span></span><br><span class="line">            ERROR; </span><br><span class="line">        &#125;<span class="keyword">else</span><span class="comment">/*PC=(2*y0=x0)^(x0&lt;=y0+10) //x=2,y=1</span></span><br><span class="line"><span class="comment">            S4:solve (2*y0=x0)^(x0&gt;y0+10),</span></span><br><span class="line"><span class="comment">            and generate new input:&#123;x=30,7=15&#125;</span></span><br><span class="line"><span class="comment">            */</span> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">/*PC=(2*y0!=x0) //x=22.y=7</span></span><br><span class="line"><span class="comment">    	S2:solve (2*y0=x0) </span></span><br><span class="line"><span class="comment">    	and generate new input:&#123;x=2,y=1&#125;</span></span><br><span class="line"><span class="comment">    	*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> main()&#123;</span><br><span class="line">    x=sym.input();</span><br><span class="line">    y=sym_input();</span><br><span class="line">    <span class="comment">/*S1:generate random input:&#123;x=22,y=7&#125;*/</span></span><br><span class="line">    testme(x,y);</span><br><span class="line">    <span class="keyword">return</span> ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一条执行路径：input={x=22,y=7}，$S1\rightarrow S2$，生成{x=2,y=1}；</p>
<p>第二条执行路径：input={x=2,y=1}，$S3\rightarrow S4$，生成{x=30,y=15}；</p>
<p>第三条执行路径：input={x=30,y=15}，$S5$，结束。</p>
<h2 id="执行生成测试EGT-execution-generated-testing"><a href="#执行生成测试EGT-execution-generated-testing" class="headerlink" title="执行生成测试EGT(execution-generated testing)"></a>执行生成测试EGT(execution-generated testing)</h2><p>EGT混合具体执行和符号执行。</p>
<p>EGT在执行每个操作之前，动态地检查每个相关值是否是具体的，如果是具体的，就正常按照源代码执行；如果至少有一个变量是符号化的，就符号化地执行——为当前程序路径更新PC。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">twice</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testme</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    z=twice(y);<span class="comment">//z=20, 按照源代码执行</span></span><br><span class="line">    <span class="keyword">if</span>(z==x)&#123;<span class="comment">//=&gt; if(20==x)</span></span><br><span class="line">        <span class="comment">//add x=20</span></span><br><span class="line">        <span class="keyword">if</span>(x&gt;y+<span class="number">10</span>)&#123;<span class="comment">//=&gt;if(x&gt;20)</span></span><br><span class="line">            <span class="comment">//infeasible</span></span><br><span class="line">            ERROR; </span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            <span class="comment">//x=20</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    	<span class="comment">//add x!=20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> main()&#123;</span><br><span class="line">    x=sym.input();</span><br><span class="line">    y=<span class="number">10</span>;<span class="comment">//instead of y=sym_input()</span></span><br><span class="line">    testme(x,y);</span><br><span class="line">    <span class="keyword">return</span> ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="动态符号执行的不精准性vs-完整性"><a href="#动态符号执行的不精准性vs-完整性" class="headerlink" title="动态符号执行的不精准性vs.完整性"></a>动态符号执行的不精准性vs.完整性</h2><h3 id="使用具体值缓解不精确性，以牺牲完整性为代价"><a href="#使用具体值缓解不精确性，以牺牲完整性为代价" class="headerlink" title="使用具体值缓解不精确性，以牺牲完整性为代价"></a>使用具体值缓解不精确性，以牺牲完整性为代价</h3><p>混合具体执行和符号执行的一个关键优点是：与外部代码的交互或约束求解超时所造成的不精确性，可以通过使用具体值来缓解。</p>
<p><strong>与外部代码交互的角度</strong>：如果传递给调库、系统调用的参数是具体的，则可以像在源代码中简单地具体执行该调用。即使某些操作数是符号化的，动态符号执行也可以使用符号操作数的具体值之一，例如在EGT中寻找满足当前路径约束的具体值来完成。</p>
<p><strong>约束求解超时的角度</strong>：符号执行中一些不精确性会蔓延，例如未处理的操作或一些导致约束求解器超时的复杂函数。具体值的使用允许动态符号执行从该不精确中恢复，以丢失某些执行路径为代价，从而牺牲了完整性。</p>
<p><strong>讨论上述导致约束求解器超时的复杂函数的问题</strong>：假定约束求解器无法解决非线性的约束，而程序中恰好有一个处理函数在做非线性的运算，那么混合测试就无法针对一条待选的执行路径有效地生成新的输入值。为了解决这种情况，混合测试以具体值替换一些符号值，使得生成的约束是简化的（simplified），而且可以被现有的约束求解器解决。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//int twice（int v）&#123;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">squareMod50</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;<span class="comment">//non-linear funtion</span></span><br><span class="line">    <span class="keyword">return</span> (v*v)%<span class="number">50</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testme</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    z=squareMod50(y); <span class="comment">//替换y0为7，sigma=&#123;x-&gt;x0,y-&gt;7&#125;</span></span><br><span class="line">    <span class="comment">//z=49</span></span><br><span class="line">    <span class="keyword">if</span>(z==x)&#123;<span class="comment">//simplified as (x0==49)</span></span><br><span class="line">        <span class="keyword">if</span>(x&gt;y+<span class="number">10</span>)&#123;<span class="comment">//混合测试生成input&#123;x=49,y=7&#125;</span></span><br><span class="line">            ERROR; </span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    	<span class="comment">//simplified as (x0!=49)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> main()&#123;</span><br><span class="line">    x=sym.input();</span><br><span class="line">    y=sym_input();</span><br><span class="line">    <span class="comment">/*sigma=&#123;x-&gt;x0,y-&gt;y0&#125;*/</span></span><br><span class="line">    testme(x,y);</span><br><span class="line">    <span class="keyword">return</span> ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>传统符号执行就没有办法做这样的简化工作(simplication)，因为符号执行过程中不允许用具体值。</p>
<p>当符号执行在一条执行路径卡住时，动态符号执行可以利用具体值为执行路径生成测试输入值以简化约束。但是<strong>达成简化可能会牺牲完整性</strong>——可能就不会为个别执行路径生成测试输入。</p>
<h1 id="主要挑战和解决方案"><a href="#主要挑战和解决方案" class="headerlink" title="主要挑战和解决方案"></a>主要挑战和解决方案</h1><p>讨论符号执行面对的主要挑战以及几个应对的解决方案。</p>
<h2 id="路径爆炸-Path-Explosion"><a href="#路径爆炸-Path-Explosion" class="headerlink" title="路径爆炸(Path Explosion)"></a>路径爆炸(Path Explosion)</h2><p>符号执行的一大挑战：程序无论大小，总有大量的执行路径，其数量基本上是程序分支数的指数级别的量。所以，如果给给定一段时间，符号执行会先尽量遍历关键路径。</p>
<p>首先，符号执行会隐式地过滤两种路径：</p>
<ol>
<li>不依赖符号输入值的路径；</li>
<li>对于当前路径约束不可解的路径。</li>
</ol>
<p>另外，路径爆炸是符号执行所面临的最大挑战之一。解决路径爆炸的两个关键方法是：</p>
<ol>
<li>启发式地优先探索最有前途的路径。</li>
<li>使用可靠的程序分析技术来降低路径探索的复杂性。</li>
</ol>
<h3 id="启发式技术-heuristic-techniques"><a href="#启发式技术-heuristic-techniques" class="headerlink" title="启发式技术(heuristic techniques)"></a><strong>启发式技术</strong>(heuristic techniques)</h3><p>符号执行工具排列路径探索优先级的主要机制：搜索的启发式。多数的启发式会关注实现对于语句和分支的高覆盖，也可以用于满足我们需要的标准。</p>
<p>方法1：利用<strong>静态的控制流图(CFG)</strong>来将爆炸引导向最近的一条路径。</p>
<p>方法2：<strong>基于随机探索的启发式</strong>。程序从头开始，在每个符号化分支两个分叉中随机选择一个去探索。</p>
<p>方法3：将<strong>随机测试和符号探索交错</strong>起来的方法。这种方法结合了随机测试快速到达深度执行状态的能力，以及符号执行彻底探索给定邻域中状态的能力。</p>
<p>方法4：<strong>符号执行与进化搜索相结合</strong>，在进化搜索中使用适应度函数来驱动对输入空间的探索。Austin工具将<u>基于搜索的软件测试</u>与<u>动态符号执行</u>相结合，前者使用合适的适应度函数来驱动测试输入空间的演化搜索，后者利用这两个方面的优点。</p>
<p>基于搜索的软件测试的有效性取决于其适应度函数的质量。</p>
<p>利用动态和静态分析的具体状态信息或符号信息来改进适应度函数，从而更好地生成测试。</p>
<h3 id="程序彻底分析技术-sound-program-analysis-techniques"><a href="#程序彻底分析技术-sound-program-analysis-techniques" class="headerlink" title="程序彻底分析技术(sound program analysis techniques):"></a><strong>程序彻底分析技术</strong>(sound program analysis techniques):</h3><p>利用程序分析和软件验证的各种思想，以合理的方式减少路径探索的复杂性。</p>
<p>可以用来减少探索路径数量的一种简单方法是使用$select$表达式将它们<strong>静态合并</strong>，然后将这些$select$表达式直接传递给约束求解器。这种方法可以解决很多情况的问题，但是它也将复杂性传递给了约束求解器——新的挑战：约束求解的复杂度。</p>
<p>组合技术通过在后续计算中缓存和重用<strong>低层函数</strong>的分析来改进符号执行。关键思想是计算每个待测函数的函数概要(根据函数输入和输出的前置和后置条件进行描述)，然后在更高级别的函数中重用这些概要。延迟测试生成是一种类似于静态软件验证中的反例导向细化范例的方法。该技术首先使用动态符号执行，通过用无约束的输入替换每个调用的函数，探索被测函数的抽象。</p>
<p>避免重复探索代码相同部分的相关方法：在探索过程中<strong>自动修剪冗余路径</strong>——具有相同符号约束的相同程序点的路径可以丢弃。类似的技术工作原理是将输入分割成互不干扰的块，然后分别进行研究。</p>
<h2 id="约束求解-Constraint-Solving"><a href="#约束求解-Constraint-Solving" class="headerlink" title="约束求解(Constraint Solving)"></a>约束求解(Constraint Solving)</h2><p>约束求解在符号执行中占主导地位，也是符号执行的技术瓶颈。符号执行在某些程序中无法扩展的一个关键原因是，它们的代码所生成的查询会破坏求解程序。</p>
<p>实现<strong>约束求解器优化</strong>成了解决这个技术瓶颈的手段。</p>
<h3 id="消除不相关的约束-Irrelevant-constraint-elimination"><a href="#消除不相关的约束-Irrelevant-constraint-elimination" class="headerlink" title="消除不相关的约束(Irrelevant constraint elimination)"></a><strong>消除不相关的约束</strong>(Irrelevant constraint elimination)</h3><p>符号执行中的绝大多数查询都是为了确定某个分支的可行性而发出的。一个重要的发现是，通常一个程序分支只依赖于少量的程序变量，因此依赖于路径条件的少量约束。</p>
<p>因此，一种有效的优化是从路径条件中<strong>移除那些与决定当前分支的结果无关的约束</strong>。</p>
<p>例如，让当前执行的路径条件为</p>
<script type="math/tex; mode=display">
{(x+y>10)}\wedge{(z>0)}\wedge{(y<12)}\wedge{(z-x=0)}</script><p>并且我们希望针对如下的新条件生成输入</p>
<script type="math/tex; mode=display">
{(x+y>10)}\wedge{(z>0)}\wedge{\neg{(y<12)}}</script><p>其中，$\neg (y&lt;12)$是是我们试图建立其可行性的否定分支条件。此时，删除条件$(z-x=0)$是安全的，因为约束不会影响到 $y&lt;12$ 的分支。</p>
<p>这个简化约束集的解将为x和y提供新的值，我们使用当前执行的z值来生成新的输入。更正式地说，该算法通过查看否定约束所依赖的所有约束之间是否共享任何变量来计算它们的传递闭包。</p>
<h3 id="递增求解-Incremental-solving"><a href="#递增求解-Incremental-solving" class="headerlink" title="递增求解(Incremental solving)"></a><strong>递增求解</strong>(Incremental solving)</h3><p>在符号执行过程中产生的约束集的一个重要特征是，它们以程序源代码中一组固定的静态分支来表示。因此，许多路径都有类似的约束集，因此允许有类似的约束;可以利用这一事实，通过<strong>重用以前类似查询的结果来提高约束求解的速度</strong>。</p>
<p>在KLEE中，所有查询结果都存储在一个缓存中，该缓存将约束集映射为具体的变量赋值，或者在约束集不可满足时映射一个特殊的无解决方案标志)。</p>
<h2 id="内存建模-Memory-Modeling"><a href="#内存建模-Memory-Modeling" class="headerlink" title="内存建模(Memory Modeling)"></a>内存建模(Memory Modeling)</h2><p>将程序语句转换为符号约束的精度对符号执行实现的覆盖率以及约束解决的可伸缩性有很大的影响。例如,使用一个内存模型近似固定宽度的整数变量与实际数学整数可能更有效,但另一方面可能导致不精确的分析代码取决于角落算术溢出等情况下,这可能导致符号执行遗漏路径或探索不可行。</p>
<h2 id="并发控制-Handling-Concurrency"><a href="#并发控制-Handling-Concurrency" class="headerlink" title="并发控制(Handling Concurrency)"></a>并发控制(Handling Concurrency)</h2><p>大型的实际程序通常是并发的。由于这些程序固有的非确定性，测试非常困难。尽管存在这些挑战，动态符号执行已被有效地用于测试并发程序，包括具有复杂输入数据的应用、分布式系统和GPGPU prog中的复杂数据应用程序。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>符号执行已经成为一种有效的程序测试技术，它提供了一种自动生成输入的方法，可以触发从低级程序崩溃到高级语义属性等各种软件错误;生成测试套件，实现高覆盖率的程序;并提供每个路径的正确性保证。</p>
<h1 id="补充资料"><a href="#补充资料" class="headerlink" title="补充资料"></a>补充资料</h1><a href="https://github.com/ksluckow/awesome-symbolic-execution#papers">Awesome Symbolic Execution</a>]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>测试</tag>
        <tag>符号执行</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux网络内核源码分析|套接字之收发数据、监听、连接、绑定</title>
    <url>/2020/01/09/Linux%E7%BD%91%E7%BB%9C%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%A5%97%E6%8E%A5%E5%AD%97%E4%B9%8B%E6%94%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E3%80%81%E7%9B%91%E5%90%AC%E3%80%81%E8%BF%9E%E6%8E%A5%E3%80%81%E7%BB%91%E5%AE%9A/</url>
    <content><![CDATA[<h1 id="INET套接字类型"><a href="#INET套接字类型" class="headerlink" title="INET套接字类型"></a>INET套接字类型</h1><ul>
<li>SOCK_STREAM：采用TCP协议服务，提供可靠的双工顺序数据流。</li>
<li>SOCK_DGRAM：采用UDP协议服务，提供双工数据传送，不保证不丢失、不错序。</li>
<li>SOCK_RAW：未采用TCP/UDP协议，应用程序可通过该套接字与IP层交互数据。</li>
</ul>
<p>关于套接字传输数据的流程见附页流程图。</p>
<h1 id="收发数据"><a href="#收发数据" class="headerlink" title="收发数据"></a>收发数据</h1><h2 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h2><h3 id="调用过程"><a href="#调用过程" class="headerlink" title="调用过程"></a>调用过程</h3><p>当通信双方需要想对方发送/写数据时，可以调用send()、sendto()、write()函数。</p>
<p><code>send()|write()|sendto() → sys_send() → sys_sendto() → sock_sendmsg() → __sock_sendmsg() → sock-&gt;prot-&gt;sendmsg() → sk-&gt;sk_prot-&gt;sendmsg()</code></p>
<p>如果是SOCK_STREAM套接字，则最后两步是<code>→ inet_sendmsg() → tcp_sendmsg()</code></p>
<blockquote>
<p>net/socket.c</p>
</blockquote>
<h3 id="sys-send"><a href="#sys-send" class="headerlink" title="sys_send()"></a>sys_send()</h3><p>包装了sys_sendto()函数。</p>
<h3 id="sys-sendto"><a href="#sys-sendto" class="headerlink" title="sys_sendto()"></a>sys_sendto()</h3><p>向指定地址发送一个数据包：完成发送数据前的准备工作，把用户空间地址转换成内核空间地址，检查用户空间数据区是否可读，调用sock_sendmsg()函数指定具体的发送操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据协议类型执行发送数据的操作</span></span><br><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_sendto</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> __user * buff, <span class="keyword">size_t</span> len, <span class="keyword">unsigned</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">			   struct sockaddr __user *addr, <span class="keyword">int</span> addr_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line">	<span class="keyword">char</span> address[MAX_SOCK_ADDR];</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msg</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//根据套接字描述符fd查找对应的socket结构体</span></span><br><span class="line">	sock = sockfd_lookup(fd, &amp;err);</span><br><span class="line">	<span class="keyword">if</span> (!sock)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	iov.iov_base=buff; <span class="comment">//指向等待发送的数据内容缓冲区</span></span><br><span class="line">	iov.iov_len=len;</span><br><span class="line">	<span class="comment">// msg用来记录数据的发送信息</span></span><br><span class="line">	msg.msg_name=<span class="literal">NULL</span>;</span><br><span class="line">	msg.msg_iov=&amp;iov;</span><br><span class="line">	msg.msg_iovlen=<span class="number">1</span>;</span><br><span class="line">	msg.msg_control=<span class="literal">NULL</span>;</span><br><span class="line">	msg.msg_controllen=<span class="number">0</span>;</span><br><span class="line">	msg.msg_namelen=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(addr)</span><br><span class="line">	&#123;<span class="comment">//把用户空间地址转换成内核空间地址</span></span><br><span class="line">		err = move_addr_to_kernel(addr, addr_len, address);</span><br><span class="line">		<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">goto</span> out_put;</span><br><span class="line">		msg.msg_name=address;</span><br><span class="line">		msg.msg_namelen=addr_len;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (sock-&gt;file-&gt;f_flags &amp; O_NONBLOCK)</span><br><span class="line">		flags |= MSG_DONTWAIT;</span><br><span class="line">	msg.msg_flags = flags;</span><br><span class="line">	<span class="comment">//执行具体的套接字发送操作</span></span><br><span class="line">	err = sock_sendmsg(sock, &amp;msg, len);</span><br><span class="line"></span><br><span class="line">out_put:		</span><br><span class="line">	sockfd_put(sock);</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sock-sendmsg"><a href="#sock-sendmsg" class="headerlink" title="sock_sendmsg()"></a>sock_sendmsg()</h3><p>调用__sock_sendmsg()发送数据。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sock_sendmsg</span><span class="params">(struct socket *sock, struct msghdr *msg, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kiocb</span> <span class="title">iocb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock_iocb</span> <span class="title">siocb</span>;</span></span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	init_sync_kiocb(&amp;iocb, <span class="literal">NULL</span>);</span><br><span class="line">	iocb.<span class="keyword">private</span> = &amp;siocb;</span><br><span class="line">    <span class="comment">//调用__sock_sendmsg()发送数据</span></span><br><span class="line">	ret = __sock_sendmsg(&amp;iocb, sock, msg, size);</span><br><span class="line">	<span class="keyword">if</span> (-EIOCBQUEUED == ret)</span><br><span class="line">		ret = wait_on_sync_kiocb(&amp;iocb);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自此函数起，传递的参数多了一个<code>struct kiocb</code>。</p>
<p>在Linux内核中，每个IO请求都对应一个kiocb结构体，其ki_filp成员指向对应的file指针，通过is_sync_kiocb可以判断某Kiocb是否为同步IO请求，真——同步IO请求，非真——异步IO请求。</p>
<p>块设备和网络设备本身就是异步的。只有字符设备驱动必须明确指出应支持AIO.需要说明的是AIO对于大多数字符设备而言都不是必须的。只有少数才需要。</p>
<blockquote>
<p>参考博客：<a href="https://www.cnblogs.com/hanyan225/archive/2010/10/24/1859655.html">Linux内核开发之异步通知与异步I/O</a></p>
</blockquote>
<h3 id="sock-sendmsg-1"><a href="#sock-sendmsg-1" class="headerlink" title="__sock_sendmsg()"></a>__sock_sendmsg()</h3><p>调用属于某协议族的套接字发送函数——在已指定的协议族操作集中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> __sock_sendmsg(struct kiocb *iocb, struct socket *sock, </span><br><span class="line">				 struct msghdr *msg, <span class="keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">    <span class="comment">//创建套接字时，所指定的具体协议族操作集记录在sock-&gt;ops中。</span></span><br><span class="line">    <span class="comment">//协议族操作集中发送数据的函数则为sock-&gt;ops-&gt;sendmsg。</span></span><br><span class="line">    <span class="comment">//sock-&gt;ops-&gt;sendmsg指向具体协议族操作集中注册的函数</span></span><br><span class="line">	<span class="keyword">return</span> sock-&gt;ops-&gt;sendmsg(iocb, sock, msg, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据协议类型<code>.type</code>在struct inet_protosw inetsw_array[]查询INET协议具体的操作集。如果套接字为SOCK_STREAM，则<code>.ops=&amp;inet_stream_ops</code>，在inet_stream_ops操作集中负责发送的<code>.sendmsg=inet_sendmsg</code>。</p>
<p>因此，调用sock-&gt;ops-&gt;sendmsg(iocb, sock, msg, size)；就等于调用inet_stream_ops操作集中的inet_sendmsg()函数。</p>
<p>关于inet_protosw inetsw_array数组，见我的博客：<a href="https://xingkunz.github.io/2020/01/01/Linux网络内核源码分析-关于套接字/">Linux网络内核源码分析-关于套接字</a>。</p>
<h3 id="SOCK-STREAM套接字的sock-gt-ops-gt-sendmsg-：inet-sendmsg"><a href="#SOCK-STREAM套接字的sock-gt-ops-gt-sendmsg-：inet-sendmsg" class="headerlink" title="SOCK_STREAM套接字的sock-&gt;ops-&gt;sendmsg()：inet_sendmsg()"></a>SOCK_STREAM套接字的sock-&gt;ops-&gt;sendmsg()：inet_sendmsg()</h3><blockquote>
<p>net/ipv4/af_inet.c</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_sendmsg</span><span class="params">(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,</span></span></span><br><span class="line"><span class="function"><span class="params">		 <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//得到套接字在传输层的struct sock表示结构</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> = <span class="title">sock</span>-&gt;<span class="title">sk</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* We may need to bind the socket. */</span></span><br><span class="line">	<span class="keyword">if</span> (!inet_sk(sk)-&gt;num &amp;&amp; inet_autobind(sk))</span><br><span class="line">		<span class="keyword">return</span> -EAGAIN;</span><br><span class="line">    <span class="comment">//调用传输层的数据发送方法</span></span><br><span class="line">	<span class="keyword">return</span> sk-&gt;sk_prot-&gt;sendmsg(iocb, sk, msg, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="传输层的发送方法sk-gt-sk-prot-gt-sendmsg-tcp-sendmsg"><a href="#传输层的发送方法sk-gt-sk-prot-gt-sendmsg-tcp-sendmsg" class="headerlink" title="传输层的发送方法sk-&gt;sk_prot-&gt;sendmsg(): tcp_sendmsg()"></a>传输层的发送方法sk-&gt;sk_prot-&gt;sendmsg(): tcp_sendmsg()</h3><blockquote>
<p>net/ipv4/tcp.c</p>
</blockquote>
<p>sk是struct socket sock中的指针，指向传输层套接字表示结构，sk中包含传输层协议操作集.prot成员。如果是SOCK_STREAM套接字，则.prot=&amp;tcp_prot，对应sendmsg()的函数即tcp_sendmsg()。</p>
<h2 id="接收数据"><a href="#接收数据" class="headerlink" title="接收数据"></a>接收数据</h2><h3 id="调用过程-1"><a href="#调用过程-1" class="headerlink" title="调用过程"></a>调用过程</h3><p>当通信双方从对方接收/读数据时，可以调用read()、recv()、recvfrom()函数。</p>
<p><code>recv()|read()|recvfrom() → sys_recv() → sys_recvfrom() → sock_recvfrom() → __sock_recvmsg() → sock_common_recvmsg() → sock-&gt;ops-&gt;recvmsg() →sk-&gt;sk_prot-&gt;recvmsg()</code></p>
<h3 id="sys-recv"><a href="#sys-recv" class="headerlink" title="sys_recv()"></a>sys_recv()</h3><p>包装了sys_recvfrom()函数。</p>
<h3 id="sys-recvfrom"><a href="#sys-recvfrom" class="headerlink" title="sys_recvfrom()"></a>sys_recvfrom()</h3><p>从一个套接字接收一个帧，有选择地记录发送方的地址，检查缓冲区是否可写，如果有需要，就把发送方地址从内核移到用户空间。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_recvfrom</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> __user * ubuf, <span class="keyword">size_t</span> size, <span class="keyword">unsigned</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">			     struct sockaddr __user *addr, <span class="keyword">int</span> __user *addr_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msg</span>;</span></span><br><span class="line">	<span class="keyword">char</span> address[MAX_SOCK_ADDR];</span><br><span class="line">	<span class="keyword">int</span> err,err2;</span><br><span class="line">    <span class="comment">//根据套接字描述符fd找到套接字的struct socket结构</span></span><br><span class="line">	sock = sockfd_lookup(fd, &amp;err);</span><br><span class="line">	<span class="keyword">if</span> (!sock)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	msg.msg_control=<span class="literal">NULL</span>;</span><br><span class="line">	msg.msg_controllen=<span class="number">0</span>;</span><br><span class="line">	msg.msg_iovlen=<span class="number">1</span>;</span><br><span class="line">	msg.msg_iov=&amp;iov;</span><br><span class="line">	iov.iov_len=size;</span><br><span class="line">	iov.iov_base=ubuf;</span><br><span class="line">	msg.msg_name=address;</span><br><span class="line">	msg.msg_namelen=MAX_SOCK_ADDR;</span><br><span class="line">	<span class="keyword">if</span> (sock-&gt;file-&gt;f_flags &amp; O_NONBLOCK)</span><br><span class="line">		flags |= MSG_DONTWAIT;</span><br><span class="line">    <span class="comment">//调用sock_recvmsg执行具体的数据接收操作</span></span><br><span class="line">	err=sock_recvmsg(sock, &amp;msg, size, flags);</span><br><span class="line">	<span class="keyword">if</span>(err &gt;= <span class="number">0</span> &amp;&amp; addr != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">//将内核空间的网络数据复制到用户空间</span></span><br><span class="line">		err2=move_addr_to_user(address, msg.msg_namelen, addr, addr_len);</span><br><span class="line">		<span class="keyword">if</span>(err2&lt;<span class="number">0</span>)</span><br><span class="line">			err=err2;</span><br><span class="line">	&#125;</span><br><span class="line">	sockfd_put(sock);			</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sock-recvmsg"><a href="#sock-recvmsg" class="headerlink" title="sock_recvmsg()"></a>sock_recvmsg()</h3><p>调用__sock_recvmsg()接收数据。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sock_recvmsg</span><span class="params">(struct socket *sock, struct msghdr *msg, </span></span></span><br><span class="line"><span class="function"><span class="params">		 <span class="keyword">size_t</span> size, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kiocb</span> <span class="title">iocb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock_iocb</span> <span class="title">siocb</span>;</span></span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">        init_sync_kiocb(&amp;iocb, <span class="literal">NULL</span>);</span><br><span class="line">	iocb.<span class="keyword">private</span> = &amp;siocb;</span><br><span class="line">	ret = __sock_recvmsg(&amp;iocb, sock, msg, size, flags);</span><br><span class="line">	<span class="keyword">if</span> (-EIOCBQUEUED == ret)</span><br><span class="line">		ret = wait_on_sync_kiocb(&amp;iocb);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sock-recvmsg（"><a href="#sock-recvmsg（" class="headerlink" title="__sock_recvmsg（)"></a>__sock_recvmsg（)</h3><p>调用属于某协议族的套接字接收函数——在已指定的协议族操作集中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> __sock_recvmsg(struct kiocb *iocb, struct socket *sock, </span><br><span class="line">				 struct msghdr *msg, <span class="keyword">size_t</span> size, <span class="keyword">int</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">    <span class="comment">//创建套接字时，所指定的具体协议族操作集记录在sock-&gt;ops中。</span></span><br><span class="line">    <span class="comment">//协议族操作集中接收数据的函数则为sock-&gt;ops-&gt;recvmsg。</span></span><br><span class="line">    <span class="comment">//sock-&gt;ops-&gt;sendmsg指向具体协议族操作集中注册的函数</span></span><br><span class="line">	<span class="keyword">return</span> sock-&gt;ops-&gt;recvmsg(iocb, sock, msg, size, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据协议类型<code>.type</code>在struct inet_protosw inetsw_array[]查询INET协议具体的操作集。如果套接字为SOCK_STREAM，则<code>.ops=&amp;inet_stream_ops</code>，在inet_stream_ops操作集中负责接收的<code>.recvmsg=sock_common_recvmsg</code>。</p>
<p>因此，调用sock-&gt;ops-&gt;recvmsg(iocb, sock, msg, size)；就等于调用inet_stream_ops操作集中的sock_common_recvmsg()函数。</p>
<h3 id="SOCK-STREAM套接字的sock-gt-ops-gt-recvmsg-sock-common-recvmsg"><a href="#SOCK-STREAM套接字的sock-gt-ops-gt-recvmsg-sock-common-recvmsg" class="headerlink" title="SOCK_STREAM套接字的sock-&gt;ops-&gt;recvmsg():sock_common_recvmsg()"></a>SOCK_STREAM套接字的sock-&gt;ops-&gt;recvmsg():sock_common_recvmsg()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sock_common_recvmsg</span><span class="params">(struct kiocb *iocb, struct socket *sock,struct msghdr *msg, <span class="keyword">size_t</span> size, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//得到传输层协议套接字</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> = <span class="title">sock</span>-&gt;<span class="title">sk</span>;</span></span><br><span class="line">	<span class="keyword">int</span> addr_len = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line">    <span class="comment">//调用传输层的数据接收函数</span></span><br><span class="line">	err = sk-&gt;sk_prot-&gt;recvmsg(iocb, sk, msg, size, flags &amp; MSG_DONTWAIT,flags &amp; ~MSG_DONTWAIT, &amp;addr_len);</span><br><span class="line">	<span class="keyword">if</span> (err &gt;= <span class="number">0</span>)</span><br><span class="line">		msg-&gt;msg_namelen = addr_len;</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据套接字采用的传输层协议，sock_common_recvmsg()调用属于不同协议的接收函数。该函数在inet_create()时指定在inetsw_array中。</p>
<p>当套接字为SOCK_STREAM时，有.prot=&amp;tcp_prot，操作集中.recvmsg=tcp_recvmsg。所以sock_common_recvmsg()调用sk-&gt;sk_prot-&gt;recvmsg就等于调用tcp_recvmsg()。</p>
<h3 id="传输层的接收方法sk-gt-sk-prot-gt-recvmsg-tcp-recvmsg"><a href="#传输层的接收方法sk-gt-sk-prot-gt-recvmsg-tcp-recvmsg" class="headerlink" title="传输层的接收方法sk-&gt;sk_prot-&gt;recvmsg(): tcp_recvmsg()"></a>传输层的接收方法sk-&gt;sk_prot-&gt;recvmsg(): tcp_recvmsg()</h3><blockquote>
<p>net/ipv4/tcp.c</p>
</blockquote>
<h1 id="监听套接字"><a href="#监听套接字" class="headerlink" title="监听套接字"></a>监听套接字</h1><h2 id="调用过程-2"><a href="#调用过程-2" class="headerlink" title="调用过程"></a>调用过程</h2><p><code>listen() → sys_listen()</code></p>
<p>调用listen()函数，程序触发内核的sys_listen()函数，</p>
<h2 id="sys-listen"><a href="#sys-listen" class="headerlink" title="sys_listen()"></a>sys_listen()</h2><blockquote>
<p>net/socket.c</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_listen</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> backlog)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line">    <span class="comment">//通过套接字描述符找到套接字对应的struct socket结构</span></span><br><span class="line">	<span class="keyword">if</span> ((sock = sockfd_lookup(fd, &amp;err)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((<span class="keyword">unsigned</span>) backlog &gt; sysctl_somaxconn)</span><br><span class="line">			backlog = sysctl_somaxconn;</span><br><span class="line"></span><br><span class="line">		err = security_socket_listen(sock, backlog);</span><br><span class="line">		<span class="keyword">if</span> (err) &#123;</span><br><span class="line">			sockfd_put(sock);</span><br><span class="line">			<span class="keyword">return</span> err;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//根据套接字协议族类型调用监听函数</span></span><br><span class="line">		err=sock-&gt;ops-&gt;listen(sock, backlog);</span><br><span class="line">		sockfd_put(sock);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是INET套接字，且为SOCK_STREAM类型，则调用sock-&gt;ops-&gt;listen()等于调用inet_listen()。</p>
<h1 id="套接字连接"><a href="#套接字连接" class="headerlink" title="套接字连接"></a>套接字连接</h1><h2 id="被动接收连接-accept"><a href="#被动接收连接-accept" class="headerlink" title="被动接收连接 accept()"></a>被动接收连接 accept()</h2><p><code>accept() → sys_accept() → sock-&gt;ops-&gt;accept()</code></p>
<p>调用accept()函数时，程序触发sys_accept()，等待接收连接请求，如果允许连接，则重新创建一个代表该连接的套接字，并返回其套接字描述符。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_accept</span><span class="params">(<span class="keyword">int</span> fd, struct sockaddr __user *upeer_sockaddr, <span class="keyword">int</span> __user *upeer_addrlen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>, *<span class="title">newsock</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err, len;</span><br><span class="line">	<span class="keyword">char</span> address[MAX_SOCK_ADDR];</span><br><span class="line">    <span class="comment">//通过套接字描述符找到套接字对应的socket结构</span></span><br><span class="line">	sock = sockfd_lookup(fd, &amp;err);</span><br><span class="line">	<span class="keyword">if</span> (!sock)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">    <span class="comment">//创建一个新的套接字</span></span><br><span class="line">	err = -EMFILE;</span><br><span class="line">	<span class="keyword">if</span> (!(newsock = sock_alloc())) </span><br><span class="line">		<span class="keyword">goto</span> out_put;</span><br><span class="line">	newsock-&gt;type = sock-&gt;type;</span><br><span class="line">	newsock-&gt;ops = sock-&gt;ops;</span><br><span class="line">    <span class="comment">//根据套接字协议族类型调用接收连接请求的函数</span></span><br><span class="line">    <span class="comment">//如果是INET协议套接字，则调用函数inet_accept</span></span><br><span class="line">	err = security_socket_accept(sock, newsock);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> out_release;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We don't need try_module_get here, as the listening socket (sock)</span></span><br><span class="line"><span class="comment">	 * has the protocol module (sock-&gt;ops-&gt;owner) held.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	__module_get(newsock-&gt;ops-&gt;owner);</span><br><span class="line">    <span class="comment">//将地址信息从内核空间复制到用户空间</span></span><br><span class="line">	err = sock-&gt;ops-&gt;accept(sock, newsock, sock-&gt;file-&gt;f_flags);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> out_release;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (upeer_sockaddr) &#123;</span><br><span class="line">		<span class="keyword">if</span>(newsock-&gt;ops-&gt;getname(newsock, (struct sockaddr *)address, &amp;len, <span class="number">2</span>)&lt;<span class="number">0</span>) &#123;</span><br><span class="line">			err = -ECONNABORTED;</span><br><span class="line">			<span class="keyword">goto</span> out_release;</span><br><span class="line">		&#125;</span><br><span class="line">		err = move_addr_to_user(address, len, upeer_sockaddr, upeer_addrlen);</span><br><span class="line">		<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">goto</span> out_release;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* File flags are not inherited via accept() unlike another OSes. */</span></span><br><span class="line">	<span class="keyword">if</span> ((err = sock_map_fd(newsock)) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> out_release;</span><br><span class="line">	security_socket_post_accept(sock, newsock);</span><br><span class="line">out_put:</span><br><span class="line">	sockfd_put(sock);</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">out_release:</span><br><span class="line">	sock_release(newsock);</span><br><span class="line">	<span class="keyword">goto</span> out_put;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="主动连接-connect"><a href="#主动连接-connect" class="headerlink" title="主动连接 connect()"></a>主动连接 connect()</h2><p><code>connect() → sys_connect() → sock-&gt;ops-&gt;connect()</code></p>
<p>调用connect()发出连接请求，内核会启动函数sys_connect()。如果采用TCP协议，则将启动TCP三次握手过程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_connect</span><span class="params">(<span class="keyword">int</span> fd, struct sockaddr __user *uservaddr, <span class="keyword">int</span> addrlen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line">	<span class="keyword">char</span> address[MAX_SOCK_ADDR];</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line">    <span class="comment">//通过套接字描述符找到套接字的socket结构</span></span><br><span class="line">	sock = sockfd_lookup(fd, &amp;err);</span><br><span class="line">	<span class="keyword">if</span> (!sock)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">    <span class="comment">//将地址信息从用户空间复制到内核空间</span></span><br><span class="line">	err = move_addr_to_kernel(uservaddr, addrlen, address);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> out_put;</span><br><span class="line"></span><br><span class="line">	err = security_socket_connect(sock, (struct sockaddr *)address, addrlen);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> out_put;</span><br><span class="line">    <span class="comment">//根据套接字协议族类型调用连接请求函数</span></span><br><span class="line">    <span class="comment">//如果是INET套接字，则调用函数inet_connect()</span></span><br><span class="line">	err = sock-&gt;ops-&gt;connect(sock, (struct sockaddr *) address, addrlen,</span><br><span class="line">				 sock-&gt;file-&gt;f_flags);</span><br><span class="line">out_put:</span><br><span class="line">	sockfd_put(sock);</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="关闭连接-shutdown"><a href="#关闭连接-shutdown" class="headerlink" title="关闭连接 shutdown()"></a>关闭连接 shutdown()</h2><p><code>shutdown() → sys_shutdown() → sock-&gt;ops-&gt;shutdown()</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_shutdown</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> how)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line">    <span class="comment">//通过套接字描述符找到套接字对应的socket结构</span></span><br><span class="line">	<span class="keyword">if</span> ((sock = sockfd_lookup(fd, &amp;err))!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		err = security_socket_shutdown(sock, how);</span><br><span class="line">		<span class="keyword">if</span> (err) &#123;</span><br><span class="line">			sockfd_put(sock);</span><br><span class="line">			<span class="keyword">return</span> err;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//根据套接字协议族调用关闭套接字的函数</span></span><br><span class="line">        <span class="comment">//如果是INET套接字，则调用函数inet_shutdown</span></span><br><span class="line">		err=sock-&gt;ops-&gt;shutdown(sock, how);</span><br><span class="line">		sockfd_put(sock);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="绑定套接字"><a href="#绑定套接字" class="headerlink" title="绑定套接字"></a>绑定套接字</h1><p><code>bind() → sys_bind()</code></p>
<blockquote>
<p>net/socket.c</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_bind</span><span class="params">(<span class="keyword">int</span> fd, struct sockaddr __user *umyaddr, <span class="keyword">int</span> addrlen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line">	<span class="keyword">char</span> address[MAX_SOCK_ADDR];</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line">    <span class="comment">//通过套接字描述符找到套接字对应的socket结构</span></span><br><span class="line">	<span class="keyword">if</span>((sock = sockfd_lookup(fd,&amp;err))!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">//将地址信息从用户空间复制到内核空间</span></span><br><span class="line">        <span class="keyword">if</span>((err=move_addr_to_kernel(umyaddr,addrlen,address))&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">    err = security_socket_bind(sock, (struct sockaddr *)address, addrlen);</span><br><span class="line">			<span class="keyword">if</span> (err) &#123;</span><br><span class="line">				sockfd_put(sock);</span><br><span class="line">				<span class="keyword">return</span> err;</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">//根据套接字协议族调用绑定地址的函数</span></span><br><span class="line">            <span class="comment">//如果是INET套接字，则调用函数inet_bind()</span></span><br><span class="line">			err = sock-&gt;ops-&gt;bind(sock, (struct sockaddr *)address, addrlen);</span><br><span class="line">		&#125;</span><br><span class="line">		sockfd_put(sock);</span><br><span class="line">	&#125;			</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="附-TCP-UDP数据传输流程"><a href="#附-TCP-UDP数据传输流程" class="headerlink" title="附:TCP/UDP数据传输流程"></a>附:TCP/UDP数据传输流程</h1><img src="/2020/01/09/Linux网络内核源码分析-套接字之收发数据、监听、连接、绑定/tcp-socket.png" title="TCP协议数据传输流程">
<img src="/2020/01/09/Linux网络内核源码分析-套接字之收发数据、监听、连接、绑定/udp-socket.png" title="UDP协议数据传输流程">]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>套接字</tag>
        <tag>网络</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo|关于博客图片无法显示的问题</title>
    <url>/2020/01/08/hexo-%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="引用本地图片方式不对"><a href="#引用本地图片方式不对" class="headerlink" title="引用本地图片方式不对"></a>引用本地图片方式不对</h2><p>注意！markdown语法在这里是没有用的！</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![](/images/image.jpg)</span><br></pre></td></tr></table></figure>
<p>markdown语法在本地编辑的过程中是有用的，图片可见，一旦部署，通过域名访问是看不到图片的。</p>
<h3 id="正确的方式：文章资源文件夹-asset"><a href="#正确的方式：文章资源文件夹-asset" class="headerlink" title="正确的方式：文章资源文件夹+asset"></a>正确的方式：文章资源文件夹+asset</h3><p>首先要打开资源文件管理功能：将 <code>config.yml</code> 文件中的 <code>post_asset_folder</code> 选项设为 <code>true</code> 来打开。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">_config.yml</span></span><br><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>当资源文件管理功能打开后，Hexo将会在你每一次通过 <code>hexo new [layout]</code> 命令创建新文章时自动创建一个文件夹。这个资源文件夹将会有与这个文章文件一样的名字。例如：<code>hexo n &quot;一篇博客&quot;</code>，则会在source中产生一个<code>一篇博客.md</code>和<code>一篇博客</code>文件夹。</p>
<p>当你在<code>一篇博客.md</code>插入一个图片时，在文件夹<code>一篇博客</code>中添加该图片文件<code>example.jpg</code>，使用asset语法：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% asset_img example.jpg 这是一个图片 %&#125;</span><br></pre></td></tr></table></figure>
<p>发布后就可以看到图片了。</p>
<blockquote>
<p>参考：<a href="https://hexo.io/zh-cn/docs/asset-folders">hexo官方文档|资源文件夹</a></p>
</blockquote>
<h2 id="引用时难以察觉的错误（脏话）"><a href="#引用时难以察觉的错误（脏话）" class="headerlink" title="引用时难以察觉的错误（脏话）"></a>引用时难以察觉的错误（脏话）</h2><p>如果你在博客对应的资源文件夹中放<code>example.JPG</code>，但是在<code>.md</code>中写的是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% asset_img example.jpg 这是一个图片 %&#125;</span><br></pre></td></tr></table></figure>
<p>则图片也不会显示。</p>
<p>所以使用前要<strong>检查属性中显示的图片格式大小写！</strong></p>
<p>因为文件夹详细信息里显示的统一都是<code>PNG图片文件</code>，所以会很难察觉。气死我了……</p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux网络内核源码分析|套接字相关的数据结构和功能实现</title>
    <url>/2020/01/01/Linux%E7%BD%91%E7%BB%9C%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%A5%97%E6%8E%A5%E5%AD%97%E7%9B%B8%E5%85%B3%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="管理套接字的数据类型"><a href="#管理套接字的数据类型" class="headerlink" title="管理套接字的数据类型"></a>管理套接字的数据类型</h1><h2 id="套接字缓冲区类型-struct-sk-buff-struct-sk-buff-head"><a href="#套接字缓冲区类型-struct-sk-buff-struct-sk-buff-head" class="headerlink" title="套接字缓冲区类型 struct sk_buff, struct sk_buff_head"></a>套接字缓冲区类型 struct sk_buff, struct sk_buff_head</h2><blockquote>
<p>skbuff.h</p>
</blockquote>
<p>struct sk_buff是套接字缓冲区类型，用来管理网络数据包，为发/收的网络数据提供存储区域和操作方法。sk_buff数据类型贯穿数据传输全过程，是十分重要的数据结构。</p>
<p>struct sk_buff_head管理一个双向链表，来组织sk_buff。</p>
<img src="/2020/01/01/Linux网络内核源码分析-套接字相关的数据结构和功能实现/image-20191220134051960.png">
<p>sk_buff与数据存储</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> *head,<span class="comment">//缓冲区头指针</span></span><br><span class="line">		*data,<span class="comment">//数据块头指针</span></span><br><span class="line">		*tail,<span class="comment">//数据块尾指针</span></span><br><span class="line">		*end;<span class="comment">//缓冲区尾指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2020/01/01/Linux网络内核源码分析-套接字相关的数据结构和功能实现/image-20191220141837701.png">
<a href="https://xingkunz.github.io/2019/12/20/Linux网络内核源码分析-重要数据结构/#more">Linux网络内核源码分析-重要数据结构</a>
<h2 id="协议族管理类型-struct-net-proto-family"><a href="#协议族管理类型-struct-net-proto-family" class="headerlink" title="协议族管理类型 struct net_proto_family"></a>协议族管理类型 struct net_proto_family</h2><blockquote>
<p>include/linux/net.h</p>
</blockquote>
<p>管理不同协议族套接字的创建方法。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_proto_family</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span>		family;<span class="comment">//协议族标志</span></span><br><span class="line">    <span class="comment">//create指针指向具体协议族套接字的创建函数。</span></span><br><span class="line">	<span class="keyword">int</span>		(*create)(struct socket *sock, <span class="keyword">int</span> protocol);</span><br><span class="line">	<span class="keyword">short</span>		authentication;<span class="comment">//认证管理字段</span></span><br><span class="line">	<span class="keyword">short</span>		encryption;<span class="comment">//加密管理字段</span></span><br><span class="line">	<span class="keyword">short</span>		encrypt_net;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span>	*<span class="title">owner</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>linux内核通过struct net_proto_family型的net_families表来管理协议族。linux支持的协议族会被sock_register()注册到net_families数组。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_proto_family</span> *<span class="title">net_families</span>[<span class="title">NPROTO</span>];</span></span><br></pre></td></tr></table></figure>
<p>我们看看该类型还有哪些变量。</p>
<p>对于INET协议族，有：</p>
<blockquote>
<p>net/ipv4/af_inet.c</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_proto_family</span> <span class="title">inet_family_ops</span> = &#123;</span></span><br><span class="line">    .family = PF_INET,</span><br><span class="line">    .create = inet_create, <span class="comment">//给出创建方法inet_create()</span></span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于UNIX域，有unix_family_ops管理创建方法，<code>create</code>指针指向unix_create()。</p>
<blockquote>
<p>net/ipv4/af_unix.c</p>
</blockquote>
<h2 id="协议族套接字操作集-struct-proto-ops"><a href="#协议族套接字操作集-struct-proto-ops" class="headerlink" title="协议族套接字操作集 struct proto_ops"></a>协议族套接字操作集 struct proto_ops</h2><blockquote>
<p>include/linux/net.h</p>
</blockquote>
<p>协议族操作集类型，统一管理套接字操作函数。linux通过struct proto_ops类型定义的统一接口管理各种功能的函数，接口就是定义中的<strong>各种函数指针</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proto_ops</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span>	family;<span class="comment">//协议族</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span>	*<span class="title">owner</span>;</span><span class="comment">//所属模块</span></span><br><span class="line">    <span class="comment">/*各种函数接口*/</span></span><br><span class="line">	<span class="keyword">int</span>	(*release)   (struct socket *sock);<span class="comment">//释放套接字</span></span><br><span class="line">	<span class="keyword">int</span>	(*bind)	     (struct socket *sock, <span class="comment">//给套接字绑定地址</span></span><br><span class="line">				      struct sockaddr *myaddr,</span><br><span class="line">				      <span class="keyword">int</span> sockaddr_len);</span><br><span class="line">	<span class="keyword">int</span>	(*connect)   (struct socket *sock, <span class="comment">//发出连接请求</span></span><br><span class="line">				      struct sockaddr *vaddr,</span><br><span class="line">				      <span class="keyword">int</span> sockaddr_len, <span class="keyword">int</span> flags);</span><br><span class="line">	<span class="keyword">int</span>	(*socketpair)(struct socket *sock1, <span class="comment">//设置对等套接字</span></span><br><span class="line">				      struct socket *sock2);</span><br><span class="line">	<span class="keyword">int</span>	(*accept)    (struct socket *sock, <span class="comment">//接受连接请求</span></span><br><span class="line">				      struct socket *newsock, <span class="keyword">int</span> flags);</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>struct proto_ops类型也有针对不同协议的各种变量。</p>
<p>对于INET协议族的TCP和UDP协议，有inet_stream_ops和inet_dgram_ops两个变量。当INET协议族套接字采用TCP传输层协议时，由inet_stream_ops变量管理套接字操作集，通过这个操作集变量，各个函数有所指定。</p>
<blockquote>
<p>INET协议族的定义都在af_inet.c，UNIX域的定义都在af_unix.c中。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proto_ops</span> <span class="title">inet_stream_ops</span> = &#123;</span> <span class="comment">//TCP协议</span></span><br><span class="line">	.family =	PF_INET,</span><br><span class="line">	.owner =	THIS_MODULE,</span><br><span class="line">	.release =	inet_release, <span class="comment">//释放TCP套接字使用inet_release()</span></span><br><span class="line">	.bind =		inet_bind,</span><br><span class="line">	.connect =	inet_stream_connect,</span><br><span class="line">	.socketpair =	sock_no_socketpair,</span><br><span class="line">	.accept =	inet_accept,</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">struct proto_ops inet_dgram_ops = &#123; <span class="comment">//UDP协议</span></span><br><span class="line">    .family =	PF_INET,</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="套接字结构类型-struct-socket"><a href="#套接字结构类型-struct-socket" class="headerlink" title="套接字结构类型 struct socket"></a>套接字结构类型 struct socket</h2><blockquote>
<p>include/linux/net.h</p>
</blockquote>
<p>每个套接字在内核中都对应唯一的struct socket结构，该类型提供不同协议族套接字的<strong>统一表示</strong>。</p>
<p>用户程序通过唯一的套接字描述符来表示套接字，用户的<strong>套接字描述符与struct socket一一对应。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket</span> &#123;</span></span><br><span class="line">	socket_state		state; <span class="comment">//状态值</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		flags; <span class="comment">//标志</span></span><br><span class="line">    <span class="comment">//套接字的协议族操作集</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">proto_ops</span>	*<span class="title">ops</span>;</span> <span class="comment">//指向一个struct proto_ops结构；</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span>	*<span class="title">fasync_list</span>;</span> <span class="comment">//异步唤醒链表</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span>		*<span class="title">file</span>;</span> <span class="comment">//文件指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock</span>		*<span class="title">sk</span>;</span> <span class="comment">//sk指向一个struct sock结构体</span></span><br><span class="line">	<span class="keyword">wait_queue_head_t</span>	wait; <span class="comment">//等待队列</span></span><br><span class="line">	<span class="keyword">short</span>			type; <span class="comment">//传输层数据类型</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span>		passcred; <span class="comment">//授权描述</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="传输层协议操作集-struct-proto"><a href="#传输层协议操作集-struct-proto" class="headerlink" title="传输层协议操作集 struct proto"></a>传输层协议操作集 struct proto</h2><blockquote>
<p>include/net/sock.h</p>
</blockquote>
<p>struct proto封装了传输协议操作集，其中函数指针指向特定于传输协议的函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proto</span> &#123;</span></span><br><span class="line">	<span class="keyword">void</span> (*close)(struct sock *sk, <span class="keyword">long</span> timeout);</span><br><span class="line">	<span class="keyword">int</span>	(*connect)(struct sock *sk, <span class="comment">//指向传输层的发出连接请求函数</span></span><br><span class="line">				   struct sockaddr *uaddr, </span><br><span class="line">				   <span class="keyword">int</span> addr_len);</span><br><span class="line">	<span class="keyword">int</span>	(*disconnect)(struct sock *sk, <span class="keyword">int</span> flags);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *(*<span class="title">accept</span>) (<span class="title">struct</span> <span class="title">sock</span> *<span class="title">sk</span>, <span class="title">int</span> <span class="title">flags</span>, <span class="title">int</span> *<span class="title">err</span>);</span></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>针对不同的传输层协议，linux提供不同的struct proto变量来管理传输协议操作集。对于INET的TCP和UDP的协议，有struct proto <strong>tcp_prot</strong>和struct proto <strong>udp_prot</strong>，对于其他协议有struct proto <strong>raw_prot</strong>。</p>
<blockquote>
<p>net/ipv4/tcp_ipv4.c</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proto</span> <span class="title">tcp_prot</span> = &#123;</span> <span class="comment">//TCP协议</span></span><br><span class="line">	.name			= <span class="string">"TCP"</span>,</span><br><span class="line">	.close			= tcp_close,</span><br><span class="line">	.connect		= tcp_v4_connect,</span><br><span class="line">	.disconnect		= tcp_disconnect,</span><br><span class="line">	.accept			= tcp_accept,</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tcp_prot变量封装了与TCP协议相关的操作函数，为INET协议族的SOCK_STREAM套接字提供了使用TCP的方法，例如函数指针<code>connect</code>指向的tcp_v4_connect()函数发出连接请求，启动三次握手过程。</p>
<p>raw_prot变量封装了与原始数据相关的操作函数，为INET的SOCK_RAW套接字提供了<strong>访问IP层</strong>的发方法。</p>
<h2 id="套接字在传输层的表示结构-struct-sock"><a href="#套接字在传输层的表示结构-struct-sock" class="headerlink" title="套接字在传输层的表示结构 struct sock"></a>套接字在传输层的表示结构 struct sock</h2><blockquote>
<p>include/net/sock.h</p>
</blockquote>
<p>struct sock结构体代表了传输层的套接字结构，包含了与具体传输层协议相关的信息。在为套接字指定传输层协议后，struct socket的<code>sk</code>指针会指向一个与传输协议关联的struct sock。</p>
<p>struct sock结构定义（部分内容）如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock_common</span> __<span class="title">sk_common</span>;</span></span><br><span class="line">    <span class="comment">//重定义__sk_common成员</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> sk_family __sk_common.skc_family <span class="comment">//协议族类型，例如PF_INET</span></span></span><br><span class="line">    <span class="comment">//#define sk_xxx __sk_common.skc_XXX</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">atomic_t</span> sk_rmem_alloc; <span class="comment">//接收缓冲队列分配计数</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff_head</span>	<span class="title">sk_receive_queue</span>;</span> <span class="comment">//套机子缓冲区接收队列</span></span><br><span class="line">	<span class="keyword">atomic_t</span> sk_wmem_alloc; <span class="comment">//发送缓冲队列分配计数</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff_head</span>	<span class="title">sk_write_queue</span>;</span> <span class="comment">//套接字缓冲区发送队列</span></span><br><span class="line">	<span class="keyword">atomic_t</span> sk_omem_alloc; <span class="comment">//其他缓冲区队列分配计数</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">int</span> sk_sndbuf; <span class="comment">//发送缓冲区长度</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock</span>		*<span class="title">sk_pair</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">head</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">tail</span>;</span></span><br><span class="line">	&#125; sk_backlog; <span class="comment">//sk_buff结构的backlog队列</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proto</span> *<span class="title">sk_prot</span>;</span> <span class="comment">//传输层协议的操作集（struct proto）的指针，例如，传输层为UDP时，sk_prot指向udp_prot。</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span>		sk_ack_backlog;<span class="comment">//当前的侦听队列长度</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span>		sk_max_ack_backlog;<span class="comment">//最大的侦听队列长度</span></span><br><span class="line">	__u32			sk_priority;<span class="comment">//优先级</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span>		sk_type;<span class="comment">//套接字类型，例如SOCK_STREAM</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span>		sk_localroute;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span>		sk_protocol;<span class="comment">//套接字协议类型</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//一些回调函数：sock结构变化时、数据准备好时...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有套接字最后通过struct sock结构来使用网络协议栈的服务。</p>
<p>其中的sk_prot指针，根据不同的传输层协议，指向具体的struct proto变量，即一些传输层的操作集。传输层为TCP协议时，sk_prot指向的结构体等同于tcp_prot；传输层为UDP协议时，sk_prot指向的结构体等同于udp_prot。</p>
<h2 id="传输层接收方法管理-struct-net-protocol"><a href="#传输层接收方法管理-struct-net-protocol" class="headerlink" title="传输层接收方法管理 struct net_protocol"></a>传输层接收方法管理 struct net_protocol</h2><blockquote>
<p>include/net/protocol.h</p>
</blockquote>
<p>管理第四层接收数据包的方法。各协议通过注册该类型变量，来注册接收该协议接收数据包的方法。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_protocol</span> &#123;</span></span><br><span class="line">    <span class="comment">//handler指向接收数据包函数</span></span><br><span class="line">	<span class="keyword">int</span> (*handler)(struct sk_buff *skb);</span><br><span class="line">    <span class="comment">//错误处理函数</span></span><br><span class="line">	<span class="keyword">void</span> (*err_handler)(struct sk_buff *skb, u32 info);</span><br><span class="line">	<span class="keyword">int</span> no_policy;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>例如TCP初始化时，内核注册了struct net_protocol tcp_protocol来管理接收TCP数据包的方法。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_protocol</span> <span class="title">tcp_protocol</span> = &#123;</span></span><br><span class="line">    .handler = tcp_v4_rcv,</span><br><span class="line">    .err_handler = tcp_v4_err,</span><br><span class="line">    .no_policy = <span class="number">1</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="struct-inet-protosw-inetsw-array数组"><a href="#struct-inet-protosw-inetsw-array数组" class="headerlink" title="struct inet_protosw, inetsw_array数组"></a>struct inet_protosw, inetsw_array数组</h2><p>将INET套接字的协议族操作集和传输层协议操作集关联起来。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inet_protosw</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span><span class="comment">//链表头，用于结构体匹配</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> type;<span class="comment">//INET套接字类型</span></span><br><span class="line">	<span class="keyword">int</span> protocol; <span class="comment">//传输层协议号</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">proto</span>	 *<span class="title">prot</span>;</span><span class="comment">//传输层协议操作集</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">proto_ops</span> *<span class="title">ops</span>;</span><span class="comment">//协议族套接字操作集</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">int</span> capability;<span class="comment">//匹配字段</span></span><br><span class="line">	<span class="keyword">char</span> no_check;<span class="comment">//校验字段</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> flags;<span class="comment">//标志字段</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>该类型的inetsw_array[]实现了INET套接字的协议族操作集与具体的传输层协议关联。该数组在收发数据筛选函数时有用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">inet_protosw</span> <span class="title">inetsw_array</span>[] = &#123;</span></span><br><span class="line">    &#123;</span><br><span class="line">        .type=SOCK_STREAM,</span><br><span class="line">        .protocol=IPPROTO_TCP,</span><br><span class="line">        .prot=&amp;tcp_prot,</span><br><span class="line">        .ops=&amp;inet_stream_ops,</span><br><span class="line">        .capability=<span class="number">-1</span>,</span><br><span class="line">        .no_chech=<span class="number">0</span>,</span><br><span class="line">        .flag=INET_PROTOSW_PERMANENT,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//一共三个元素：SOCK_STREAM,SOCK_DGRAM,SOCKRAW</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在函数inet_init()对INET协议族进行初始化的时候，由inet_register_protosw把数组inetsw_array上记录的关联信息注册到inetsw数组中。</p>
<p>在系统使用过程中，内核以<code>套接字类型</code>为索引访问inetsw，inetsw定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">inetsw</span>[<span class="title">SOCK_MAX</span>];</span></span><br><span class="line"><span class="comment">//每一项都是一个struct inet_protosw结构体的链表</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>,*<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="套接字功能实现"><a href="#套接字功能实现" class="headerlink" title="套接字功能实现"></a>套接字功能实现</h1><p>start_kernel()调用了与网络初始化相关的函数：sock_init()、do_initcalls()等。</p>
<p>sock_init()主要完成与套接字相关的初始化，do_initcalls()完成协议初始化，inet_init()完成与INET套接字相关的初始化。</p>
<img src="/2020/01/01/Linux网络内核源码分析-套接字相关的数据结构和功能实现/image-20200108195011023.PNG">
<h2 id="套接字初始化-sock-init"><a href="#套接字初始化-sock-init" class="headerlink" title="套接字初始化 sock_init()"></a>套接字初始化 sock_init()</h2><blockquote>
<p>net/socket.c</p>
</blockquote>
<p>sock_init()主要任务是初始化套接字。具体初始化的具体内容如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> __<span class="function">init <span class="title">sock_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">//初始化协议族管理变量net_families</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NPROTO; i++) </span><br><span class="line">		net_families[i] = <span class="literal">NULL</span>;</span><br><span class="line">	sk_init();<span class="comment">//初始化套接字结构</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SLAB_SKB</span></span><br><span class="line">	skb_init();<span class="comment">//初始化套接字缓冲区</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">//初始化并注册套接字文件系统</span></span><br><span class="line">	init_inodecache();</span><br><span class="line">	register_filesystem(&amp;sock_fs_type);</span><br><span class="line">	sock_mnt = kern_mount(&amp;sock_fs_type);</span><br><span class="line">	</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NETFILTER</span></span><br><span class="line">	netfilter_init();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>协议族套接字初始化的工作由对应的初始化函数来完成。</p>
<h2 id="协议族初始化"><a href="#协议族初始化" class="headerlink" title="协议族初始化"></a>协议族初始化</h2><p>不同协议族套接字初始化都不同的函数，例如：INET协议族套接字初始化由inet_init()函数完成。</p>
<h3 id="INET协议族套接字初始化inet-init"><a href="#INET协议族套接字初始化inet-init" class="headerlink" title="INET协议族套接字初始化inet_init()"></a>INET协议族套接字初始化inet_init()</h3><blockquote>
<p>net/ipv4/af_inet.c</p>
</blockquote>
<p>INET协议族初始化时，inet_init()调用sock_register()注册INET套接字的创建方法到(struct net_proto_family)<strong>*net_families</strong>[NPROTO]中，该数组记录各协议套接字的创建方法。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">inet_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//INET协议族用(struct net_proto_family)inet_family_ops变量注册INET协议族套接字的创建方法；</span></span><br><span class="line">    <span class="comment">//根据inet_family_ops的记录，.create被指定为inet_create()函数。</span></span><br><span class="line">    (<span class="keyword">void</span>)sock_register(&amp;inet_family_ops);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//用(struct net_protocol)icmp_protocol变量注册ICMP数据包的接收方法</span></span><br><span class="line">    <span class="comment">//用(struct net_protocol)udp_protocol变量注册管理UDP数据包的接收方法</span></span><br><span class="line">    <span class="comment">//用(struct net_protocol)tcp_protocol变量注册管理TCP数据包的接收方法</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    arp_init();<span class="comment">//启动ARP模块</span></span><br><span class="line">    ip_init();<span class="comment">//启动IP模块</span></span><br><span class="line">    tcp_init();<span class="comment">//启动TCP缓存</span></span><br><span class="line">    icmp_init(&amp;inet_family_ops);<span class="comment">//启动ICMP模块，根据inet_family_ops的记录来指定创建方法。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注册协议族套接字的创建方法-sock-register"><a href="#注册协议族套接字的创建方法-sock-register" class="headerlink" title="注册协议族套接字的创建方法 sock_register()"></a>注册协议族套接字的创建方法 sock_register()</h3><blockquote>
<p>net/socket.c</p>
</blockquote>
<p>sock_register()向net_families数组中添加协议族套接字的创建方法，该数组记录各协议套接字的创建方法。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sock_register</span><span class="params">(struct net_proto_family *ops)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//传入参数为内核中记录的各协议对应的struct net_proto_family型变量，像查电话本一样，根据传入参数进行注册。</span></span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ops-&gt;family &gt;= NPROTO) &#123;</span><br><span class="line">		printk(KERN_CRIT <span class="string">"protocol %d &gt;= NPROTO(%d)\n"</span>, ops-&gt;family, NPROTO);</span><br><span class="line">		<span class="keyword">return</span> -ENOBUFS;</span><br><span class="line">	&#125;</span><br><span class="line">	net_family_write_lock();</span><br><span class="line">	err = -EEXIST;</span><br><span class="line">    <span class="comment">//通过参数ops得到其中记录的create方法等信息，添加到net_families数组中。</span></span><br><span class="line">	<span class="keyword">if</span> (net_families[ops-&gt;family] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		net_families[ops-&gt;family]=ops;</span><br><span class="line">		err = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	net_family_write_unlock();</span><br><span class="line">	printk(KERN_INFO <span class="string">"NET: Registered protocol family %d\n"</span>,</span><br><span class="line">	       ops-&gt;family);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="套接字创建流程"><a href="#套接字创建流程" class="headerlink" title="套接字创建流程"></a>套接字创建流程</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br><span class="line"><span class="comment">//参数：（协议族，套接字传输类型，指定在套接字上使用的特定协议_default0）</span></span><br><span class="line"><span class="comment">//返回：套接字描述符</span></span><br></pre></td></tr></table></figure>
<p>我们在应用层使用socket()函数创建套接字时，socket()触发内核调用sys_socket()，sys_socket()又调用sock_create()。</p>
<p>sock_create()根据一路传参下来的协议族类型参数有选择地调用不同的套接字创建函数。例如，指定的协议族类型为PF_INET，则sock_create()调用inet_create()创建INET套接字。</p>
<img src="/2020/01/01/Linux网络内核源码分析-套接字相关的数据结构和功能实现/image-20200108195011024.PNG">
<p>继续以INET套接字为例。inet_create()首先创建套接字的内核表示结构，再返回一个套接字描述符来记录生成的套接字对象。该套接字描述符一直被返回到socket()函数，从而我们可以通过调用socket()获得套接字描述符。</p>
<h3 id="INET协议套接字创建函数-inet-create"><a href="#INET协议套接字创建函数-inet-create" class="headerlink" title="INET协议套接字创建函数 inet_create()"></a>INET协议套接字创建函数 inet_create()</h3><blockquote>
<p>net/ipv4/af_inet.c</p>
</blockquote>
<p>inet_create()函数创建一个INET套接字(一个struct socket变量)，并根据套接字类型来决定传输层所采用的协议。</p>
<p>struct socket中最重要的成员是sk，它指向一个struct sock。inet_create()首先调用sk_alloc()为sock分配内存，令<code>sk</code>指向它，并按照套接字类型对其初始化。</p>
<p>例，如果<code>sock-&gt;type=SOCK_STREAM</code>，那么内核会创建TCP协议的套接字，<code>sock-&gt;ops</code>提供INET协议族操作集，<code>sock-&gt;sk-&gt;sk_prot</code>将提供TCP协议操作集。通过查询inetsw链表，inet_create()得到记录传输层协议操作集的信息。</p>
<p>针对TCP协议，查询到的结果是tcp_prot，传输协议操作集struct proto tcp_prot中记录了一系列TCP协议相关操作的函数，有关套接字初始化的函数为tcp_v4_init_sock()。</p>
<h3 id="TCP协议套接字初始化函数-tcp-v4-init-sock"><a href="#TCP协议套接字初始化函数-tcp-v4-init-sock" class="headerlink" title="TCP协议套接字初始化函数 tcp_v4_init_sock()"></a>TCP协议套接字初始化函数 tcp_v4_init_sock()</h3><p>tcp_v4_init_sock()初始化套接字与TCP有关的数据，包括初始化TCP队列、传输定时器、发送窗口、慢启动窗口、拥塞窗口控制、数据包最小长度，以及sk相关参数：套接字状态、收发缓冲区、队列有关的字段。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>套接字</tag>
        <tag>网络</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>关于区块链的笔记</title>
    <url>/2019/12/24/%E5%85%B3%E4%BA%8E%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
<p>参考：B站-是落拓呀，视频ID：75077145，75755443。</p>
</blockquote>
<p>本篇博客放置两页手写笔记，内容包括：</p>
<ol>
<li>区块链（block chain）基本概念：区块组成、链的形成、区块链应用。</li>
<li>篡改区块行为以及应对措施——工作量证明机制（POW）——的原理。</li>
<li>P2P网络，篡改数据所需要的条件。</li>
<li>计算哈希值、SHA算法和POW函数实现。</li>
</ol>
<p>下面是笔记：</p>
<img src="/2019/12/24/关于区块链的笔记/1.png">
<img src="/2019/12/24/关于区块链的笔记/2.png">
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu 16.04编译linux 4.6内核完整过程（含各种error解决方案）</title>
    <url>/2019/12/24/ubuntu-16-4%E7%BC%96%E8%AF%91linux-4-6%E5%86%85%E6%A0%B8%E5%AE%8C%E6%95%B4%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<blockquote>
<p>完整的编译过程大约会占用10GB的存储空间！谨慎！</p>
<p>如果你已有环境基础，那么整个过程会大致耗时5h+!</p>
</blockquote>
<h2 id="版本说明"><a href="#版本说明" class="headerlink" title="版本说明"></a>版本说明</h2><h3 id="环境版本"><a href="#环境版本" class="headerlink" title="环境版本"></a>环境版本</h3><p>Ubuntu版本查看方法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kun@ubuntu:~$ cat /etc/issue</span><br><span class="line">Ubuntu 16.04.6 LTS \n \l</span><br><span class="line"></span><br><span class="line">kun@ubuntu:~$ cat /proc/version</span><br><span class="line">Linux version 4.15.0-45-generic (buildd@lcy01-amd64-027) (gcc version 5.4.0 20160609 (Ubuntu 5.4.0-6ubuntu1~16.04.10)) #48~16.04.1-Ubuntu SMP Tue Jan 29 18:03:48 UTC 2019</span><br></pre></td></tr></table></figure>
<p>VMware® Workstation 15 Player</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">15.1.0 build-13591040</span><br></pre></td></tr></table></figure>
<h3 id="linux内核版本"><a href="#linux内核版本" class="headerlink" title="linux内核版本"></a>linux内核版本</h3><p>linux-4.6</p>
<p>下载链接：<a href="https://www.kernel.org/。">https://www.kernel.org/。</a></p>
<p>下载linux-4.6.tar.xz文件后复制到Ubuntu的文件系统中，我将复制到了Downloads/文件下。</p>
<h2 id="Linux内核编译"><a href="#Linux内核编译" class="headerlink" title="Linux内核编译"></a>Linux内核编译</h2><h3 id="准备编译"><a href="#准备编译" class="headerlink" title="准备编译"></a>准备编译</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 解压准备</span></span><br><span class="line">xz -d Downloads/linux-4.6.tar.xz</span><br><span class="line">tar –xvf Downloads/linux-4.6.tar</span><br><span class="line">sudo cp -r Downloads/linux-4.6 /usr/src</span><br><span class="line"><span class="built_in">cd</span> /usr/src</span><br><span class="line"><span class="comment"># 编译配置</span></span><br><span class="line">cp linux-headers-4.15.0-45-generic/.config linux-4.6/</span><br><span class="line"><span class="built_in">cd</span> linux-4.6/</span><br></pre></td></tr></table></figure>
<h3 id="内核配置"><a href="#内核配置" class="headerlink" title="内核配置"></a>内核配置</h3><p>内核提供了各种不同的工具来简化内核配置，make config/gconfig/oldconfig等，下面以基于ncurse库编制的图形界面工具配置。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make menuconfig</span><br></pre></td></tr></table></figure>
<p>出现可视化菜单，选择load→OK→Save→OK→EXIT→EXIT。</p>
<p>执行完，则内核配置完毕。</p>
<h3 id="内核配置不成功的错误"><a href="#内核配置不成功的错误" class="headerlink" title="内核配置不成功的错误"></a>内核配置不成功的错误</h3><p>如果没有出现可视化菜单，而是出现错误：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@ubuntu:/usr/src/linux-4.6# make menuconfig</span><br><span class="line">  HOSTCC  scripts/basic/fixdep</span><br><span class="line">  HOSTCC  scripts/kconfig/mconf.o</span><br><span class="line">In file included from scripts/kconfig/mconf.c:23:0:</span><br><span class="line">scripts/kconfig/lxdialog/dialog.h:38:20: fatal error: curses.h: No such file or directory</span><br><span class="line">compilation terminated.</span><br><span class="line">scripts/Makefile.host:108: recipe for target 'scripts/kconfig/mconf.o' failed</span><br><span class="line">make[1]: *** [scripts/kconfig/mconf.o] Error 1</span><br><span class="line">Makefile:538: recipe for target 'menuconfig' failed</span><br><span class="line">make: *** [menuconfig] Error 2</span><br></pre></td></tr></table></figure>
<p>解决方法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install build-essential </span><br><span class="line">sudo apt-get install libncurses5 </span><br><span class="line">sudo apt-get install libncurses5-dev</span><br></pre></td></tr></table></figure>
<p>重新尝试，在可视化菜单中选择load→OK→Save→OK→EXIT→EXIT</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@ubuntu:/usr/src/kernel/linux-4.6# make menuconfig</span><br><span class="line">  HOSTCC  scripts/kconfig/mconf.o</span><br><span class="line">  HOSTCC  scripts/kconfig/zconf.tab.o</span><br><span class="line">  HOSTCC  scripts/kconfig/lxdialog/checklist.o</span><br><span class="line">  HOSTCC  scripts/kconfig/lxdialog/util.o</span><br><span class="line">  HOSTCC  scripts/kconfig/lxdialog/inputbox.o</span><br><span class="line">  HOSTCC  scripts/kconfig/lxdialog/textbox.o</span><br><span class="line">  HOSTCC  scripts/kconfig/lxdialog/yesno.o</span><br><span class="line">  HOSTCC  scripts/kconfig/lxdialog/menubox.o</span><br><span class="line">  HOSTLD  scripts/kconfig/mconf</span><br><span class="line">scripts/kconfig/mconf  Kconfig</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*** End of the configuration.</span><br><span class="line">*** Execute 'make' to start the build or try 'make help'.</span><br></pre></td></tr></table></figure>
<p>如果出现仍错误，如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scripts/kconfig/mconf  Kconfig</span><br><span class="line">.config:4244:warning: symbol value <span class="string">'m'</span> invalid <span class="keyword">for</span> GPIO_MB86S7X</span><br><span class="line">Your display is too small to run Menuconfig!</span><br><span class="line">It must be at least 19 lines by 80 columns.</span><br><span class="line">scripts/kconfig/Makefile:28: recipe <span class="keyword">for</span> target <span class="string">'menuconfig'</span> failed</span><br><span class="line">make[1]: *** [menuconfig] Error 1</span><br><span class="line">Makefile:538: recipe <span class="keyword">for</span> target <span class="string">'menuconfig'</span> failed</span><br><span class="line">make: *** [menuconfig] Error 2</span><br></pre></td></tr></table></figure>
<p>则只需要调大终端窗口大小重试即可。</p>
<p>其他的配置工具简介如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make config ;字符界面下</span><br><span class="line">make gconfig ;基于gk+的图形工具</span><br><span class="line">make defconfig ;基于默认配置</span><br><span class="line">make oldconfig ;修改过配置文件后，或者用已有配置文件配置新的代码树的时候，应该执行</span><br></pre></td></tr></table></figure>
<h3 id="编译和安装内核"><a href="#编译和安装内核" class="headerlink" title="编译和安装内核"></a>编译和安装内核</h3><p>编译内核，仍然在你的linux-4.6/下执行，可能耗时数小时：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>
<p>老版的编译方式会编译启动映像make bzImage。这里不使用，make就可以搞定。</p>
<p>可能出现错误：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scripts/sign-file.c:25:30: fatal error: openssl/opensslv.h: No such file or directory</span><br><span class="line">compilation terminated.</span><br><span class="line">scripts/Makefile.host:91: recipe for target 'scripts/sign-file' failed</span><br><span class="line">make[1]: *** [scripts/sign-file] Error 1</span><br><span class="line">Makefile:552: recipe for target 'scripts' failed</span><br><span class="line">make: *** [scripts] Error 2</span><br></pre></td></tr></table></figure>
<p>解决方法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libssl-dev</span><br></pre></td></tr></table></figure>
<p>重新尝试make，开始等待。结束结果如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Setup is 17404 bytes (padded to 17408 bytes).</span><br><span class="line">System is 6942 kB</span><br><span class="line">CRC f4cb1ce4</span><br><span class="line">Kernel: arch/x86/boot/bzImage is ready  (#1)</span><br></pre></td></tr></table></figure>
<p>安装内核模块：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make modules_install</span><br></pre></td></tr></table></figure>
<p>就可以把已编译的模块安装到正确的主目录/lib/modules下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make install ;安装内核模块</span><br></pre></td></tr></table></figure>
<p>这一步生成新内核的引导文件。重启系统：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure>
<p>过程结束。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>教程</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言|关于作用域、链接、存储期、存储类别</title>
    <url>/2019/12/21/C%E8%AF%AD%E8%A8%80-%E5%85%B3%E4%BA%8E%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E9%93%BE%E6%8E%A5%E3%80%81%E5%AD%98%E5%82%A8%E6%9C%9F%E3%80%81%E5%AD%98%E5%82%A8%E7%B1%BB%E5%88%AB/</url>
    <content><![CDATA[<blockquote>
<p>参考《C Primer Plus》(第6版)</p>
</blockquote>
<h2 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h2><p>c提供了许多不同的模型或<strong>存储类别</strong>在内存中存储数据。</p>
<ul>
<li>对象（obect）：值占用的一块物理内存。一个对象可以存储一个/多个值。</li>
<li>标识符（entity）：程序指定硬件内存中对象的方式，用于访问对象。</li>
</ul>
<p>可以用<strong>存储期</strong>来描述对象，用<strong>作用域</strong>和<strong>链接</strong>描述标识符。</p>
<ul>
<li>存储期（storage duration）：对象在内存中保存了多长时间。</li>
<li>标识符的作用域（scope）和链接（linkage）表明了程序的哪些部分可以使用该标识符。</li>
</ul>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><ul>
<li>作用域：程序中可访问标识符的区域。</li>
</ul>
<h3 id="块作用域-block-scope"><a href="#块作用域-block-scope" class="headerlink" title="块作用域(block scope)"></a>块作用域(block scope)</h3><blockquote>
<p>块：整个函数体是一个块，函数里面任意的复合语句也是一个块。简单来说，一对“{}”括起来的区域是一个块。</p>
</blockquote>
<p>定义在块中的变量具有块作用域，块作用域的可见范围是从定义处到包含该定义的块的末尾。到目前为止，我们使用的局部变量（包括函数的形式参数）都具有块作用域。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;<span class="comment">//a的作用域开始</span></span><br><span class="line">    <span class="keyword">if</span>(n &gt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> b = a+a;<span class="comment">//b的作用域开始</span></span><br><span class="line">        <span class="comment">//只有内层块的代码可以访问b</span></span><br><span class="line">        a += b;</span><br><span class="line">    &#125;<span class="comment">//b的作用域结束</span></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;<span class="comment">//a的作用域结束</span></span><br></pre></td></tr></table></figure>
<h3 id="函数作用域-function-scope"><a href="#函数作用域-function-scope" class="headerlink" title="函数作用域(function scope)"></a>函数作用域(function scope)</h3><p>函数作用域仅用于goto语句的标签，作用域从标签位置开始延续至函数结束。与块作用域相比，突破了块的限制。标签的函数作用域避免了两个块中使用相同标签的混乱。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">bool</span> condition)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//块1</span></span><br><span class="line">    <span class="keyword">if</span>(condition)</span><br><span class="line">    &#123;</span><br><span class="line">        label:<span class="comment">//块1的label的函数作用域开始</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//块2</span></span><br><span class="line">    <span class="keyword">if</span>(!condition)</span><br><span class="line">    &#123;</span><br><span class="line">        label:<span class="comment">//块2的label的函数作用域开始</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//块1、块2的label作用域结束</span></span><br></pre></td></tr></table></figure>
<h3 id="函数原型作用域-function-prototype-scope"><a href="#函数原型作用域-function-prototype-scope" class="headerlink" title="函数原型作用域(function prototype scope)"></a>函数原型作用域(function prototype scope)</h3><p>函数原型作用域用于函数原型中的形参名。作用范围是从形参定义处到原型声明结束。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数原型声明：只注重函数类型、参数个数、参数类型，不关心形参名。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> mouse, <span class="keyword">double</span> large)</span></span>;<span class="comment">//mouse和large的作用域从这里开始、在这里结束。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数原型声明也可写作：void fun(int , double );</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">double</span> l)</span><span class="comment">//m,l是形式参数，不必与函数声明时的mouse，large一致。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//定义内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>形式参数：函数定义的函数头中声明的变量。</p>
<p>实际参数：函数调用时实际传入的参数。</p>
<p>函数声明时的参数是假名，不必与函数定义的形式参数一致。</p>
</blockquote>
<p>只有在变长数组中，函数原型的形参名才有用。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">use_a_VLA</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span> a[n][m])</span></span>;</span><br><span class="line"><span class="comment">//			   n开始----m开始----n,m被使用--n,m的函数原型作用域结束。</span></span><br><span class="line"><span class="comment">//方括号中使用的形参名是在该函数原型作用域中已声明的名称。</span></span><br></pre></td></tr></table></figure>
<h3 id="文件作用域-file-scope"><a href="#文件作用域-file-scope" class="headerlink" title="文件作用域(file scope)"></a>文件作用域(file scope)</h3><p>定义在函数外面的变量，即全局变量，具有文件作用域。作用范围从定义处到该定义所在文件的末尾。</p>
<p>具有文件作用域的变量在内存中不动。</p>
<h3 id="作用域总结"><a href="#作用域总结" class="headerlink" title="作用域总结"></a>作用域总结</h3><div class="table-container">
<table>
<thead>
<tr>
<th>作用域类别</th>
<th>作用域范围</th>
<th>应用</th>
</tr>
</thead>
<tbody>
<tr>
<td>块作用域</td>
<td>从定义处到包含该定义的块的末尾。</td>
<td>局部变量（包括函数的形式参数）都具有块作用域。</td>
</tr>
<tr>
<td>函数作用域</td>
<td>从标签位置开始延续至函数结束。</td>
<td>用于goto语句的标签。</td>
</tr>
<tr>
<td>函数原型作用域</td>
<td>从形参定义处到原型声明结束。</td>
<td>用于函数原型中的形参名。</td>
</tr>
<tr>
<td>文件作用域</td>
<td>从定义处到该定义所在文件的末尾。</td>
<td>全局变量具有文件作用域。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><blockquote>
<p>c预处理会将#include指令用包含的头文件替换掉。</p>
<p>翻译单元：源代码文件中所有#include指令被头文件替换掉后的文件。程序由多个源代码文件组成时，等于由多个翻译单元组成。</p>
</blockquote>
<p>文件作用域变量的实际可见范围是一个翻译单元。</p>
<p>c变量有三种连接属性：外部链接、内部链接、无链接。</p>
<h3 id="链接与作用域"><a href="#链接与作用域" class="headerlink" title="链接与作用域"></a>链接与作用域</h3><div class="table-container">
<table>
<thead>
<tr>
<th>链接</th>
<th>链接描述</th>
<th>作用域</th>
</tr>
</thead>
<tbody>
<tr>
<td>外部链接</td>
<td>变量可以在多文件程序中使用。</td>
<td>具有文件作用域，外部定义使用存储类别说明符static。</td>
</tr>
<tr>
<td>内部链接</td>
<td>变量可以在一个翻译单元内使用。</td>
<td>具有文件作用域，外部定义<strong>没有</strong>使用存储类别说明符static。</td>
</tr>
<tr>
<td>无链接</td>
<td>变量只属于定义它们的块、函数、原型私有。</td>
<td>具有块作用域、函数作用域、函数原型作用域。</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>; <span class="comment">//变量a具有外部链接文件作用域</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">4</span>; <span class="comment">//变量b具有内部链接文件作用域</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>习惯称“内部链接的文件作用域”为“文件作用域” ，称“外部链接的文件作用域”为“全局作用域”或“程序作用域”。</p>
</blockquote>
<h3 id="多文件"><a href="#多文件" class="headerlink" title="多文件"></a>多文件</h3><p>程序由多个翻译单元组成。</p>
<p>一个源文件中定义式声明了一个外部变量，该源文件可初始化该变量，其他文件使用该变量前需要使用关键字extern声明它以获得使用权。 </p>
<blockquote>
<p>外部变量，静态外部链接变量。</p>
</blockquote>
<h2 id="存储期"><a href="#存储期" class="headerlink" title="存储期"></a>存储期</h2><p>c对象具有四种存储期：静态存储期、线程存储期、自动存储期、动态分配存储期。</p>
<h3 id="静态存储期"><a href="#静态存储期" class="headerlink" title="静态存储期"></a>静态存储期</h3><p>具有静态存储器的对象，在程序执行期间一直存在。</p>
<p>静态变量在内存中不动，并不是值不变。</p>
<p>文件作用域变量具有静态存储期，无论是内部链接（有static）还是外部链接。</p>
<p>带有关键字static的块作用域变量也具有静态存储期。即，静态无链接存储类别。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;<span class="comment">//具有外部链接文件作用域</span></span><br><span class="line"><span class="keyword">static</span> b = <span class="number">4</span>;<span class="comment">//具有内部链接文件作用域</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> c = <span class="number">1</span>;<span class="comment">//具有无链接块作用域</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//a,b,c都具有静态存储期。</span></span><br></pre></td></tr></table></figure>
<h3 id="线程存储期"><a href="#线程存储期" class="headerlink" title="线程存储期"></a>线程存储期</h3><p>并发程序设计中，具有线程存储期的对象，从声明时到线程结束一直存在。</p>
<p>以关键字<strong>_Thread_local</strong>声明一个对象时，每个线程都获得该变量的私有备份。</p>
<h3 id="自动存储期"><a href="#自动存储期" class="headerlink" title="自动存储期"></a>自动存储期</h3><p>具有块作用域的变量通常都具有自动存储期，从进入定义变量的块到退出块时存在。进入时分配内存，退出块时释放内存。</p>
<p>自动变量所占的内存可以视为一个可重复利用的暂存区。目前我们使用的局部变量都是自动变量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a)</span><span class="comment">//a开始</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    &#123;<span class="comment">//c开始，内部a开始</span></span><br><span class="line">        <span class="keyword">int</span> c; </span><br><span class="line">        <span class="keyword">int</span> a;<span class="comment">//内层的a会屏蔽外层的a的定义</span></span><br><span class="line">    &#125;<span class="comment">//c结束，内部a结束</span></span><br><span class="line">&#125;<span class="comment">//a,b结束</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//a,b,c都是自动类别。</span></span><br><span class="line"><span class="comment">//a,b在每次调用fun()时被创建，离开fun()时被销毁。</span></span><br><span class="line"><span class="comment">//c在每次进入块时被创建，离开块时被销毁。</span></span><br></pre></td></tr></table></figure>
<p>特例：变长数组是从声明处到块的末尾。</p>
<p>属于自动存储类别的变量具有自动存储期、块作用域、无链接。</p>
<p>块作用域无链接意味着变量只能在块内通过变量名访问，不同的函数内可以有同名的变量名（但是占用不同的内存）。</p>
<h3 id="动态分配存储期"><a href="#动态分配存储期" class="headerlink" title="动态分配存储期"></a>动态分配存储期</h3><p>（无描述）</p>
<h3 id="存储期总结"><a href="#存储期总结" class="headerlink" title="存储期总结"></a>存储期总结</h3><div class="table-container">
<table>
<thead>
<tr>
<th>存储期</th>
<th>存储期描述</th>
<th>作用域和链接</th>
</tr>
</thead>
<tbody>
<tr>
<td>静态存储期</td>
<td>在程序执行期间一直存在。</td>
<td>内部/外部链接文件作用域；加static无链接块作用域。</td>
</tr>
<tr>
<td>线程存储期</td>
<td>从线程声明时到线程结束一直存在。</td>
<td></td>
</tr>
<tr>
<td>自动存储期</td>
<td>从进入定义变量的块到退出块时存在。</td>
<td>无链接，块作用域。</td>
</tr>
<tr>
<td>动态分配存储期</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h2 id="存储类别"><a href="#存储类别" class="headerlink" title="存储类别"></a>存储类别</h2><p>c使用作用域、链接、存储期为变量规定了多种存储类别。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>存储类别</th>
<th>存储期</th>
<th>作用域</th>
<th>链接</th>
<th>声明方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>自动</td>
<td>自动</td>
<td>块</td>
<td>无</td>
<td>块内</td>
</tr>
<tr>
<td>寄存器</td>
<td>自动</td>
<td>块</td>
<td>无</td>
<td>块内，加关键字register</td>
</tr>
<tr>
<td>静态外部链接</td>
<td>静态</td>
<td>文件</td>
<td>外部</td>
<td>所有函数外</td>
</tr>
<tr>
<td>静态内部链接</td>
<td>静态</td>
<td>文件</td>
<td>内部</td>
<td>所有函数外，加关键字static</td>
</tr>
<tr>
<td>静态无链接</td>
<td>静态</td>
<td>块</td>
<td>无</td>
<td>快内，加关键字static</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">1</span>;<span class="comment">//静态外部链接类别</span></span><br><span class="line"><span class="keyword">static</span> b=<span class="number">2</span>;<span class="comment">//静态内部链接类别</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> c)</span><span class="comment">//自动类别</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> d=<span class="number">3</span>;<span class="comment">//自动类别</span></span><br><span class="line">    <span class="keyword">static</span> e=<span class="number">4</span>;<span class="comment">//静态无链接类别</span></span><br><span class="line">    <span class="keyword">register</span> f=<span class="number">5</span>;<span class="comment">//寄存器类别</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="寄存器变量"><a href="#寄存器变量" class="headerlink" title="寄存器变量"></a>寄存器变量</h3><p>寄存器变量存在最快的可用内存中，幸运的话就存在CPU的寄存器中。访问和处理寄存器变量的速度更快。</p>
<p>绝大多数情况，寄存器变量和自动变量一样——无链接、块作用域、自动存储期。</p>
<p>“register”类似于一种申请，编译器可以忽略该申请，使得变量变成自动变量。由于寄存器的空间限制，可声明为“register”的数据类型有限。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">register</span> <span class="keyword">int</span> n)</span></span>&#123;<span class="comment">//请求成为寄存器变量的形参n</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> a;<span class="comment">//请求成为寄存器变量的a</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="静态外部链接变量"><a href="#静态外部链接变量" class="headerlink" title="静态外部链接变量"></a>静态外部链接变量</h3><p>又称“外部存储类别”，属于该存储类别的变量成为<strong>外部变量</strong>，具有文件作用域、外部链接、静态存储器。</p>
<p>外部变量的定义式说明在所有函数外面。</p>
<p>使用关键字extern的情况：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*情况一*/</span></span><br><span class="line"><span class="keyword">int</span> a;<span class="comment">//外部变量a的定义式声明</span></span><br><span class="line"><span class="keyword">int</span> aa[<span class="number">100</span>];<span class="comment">//外部变量aa数组的定义式声明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">int</span> a;<span class="comment">//可选的再次声明</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">int</span> aa[];<span class="comment">//可选的再次声明</span></span><br><span class="line">    <span class="comment">/*这两条完全可以省略。如果去掉extern就会成为自动变量。*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">int</span> a;<span class="comment">//a与上下文的a是同一个a。</span></span><br><span class="line">    <span class="keyword">int</span> aa[<span class="number">2</span>];<span class="comment">//fun()里的自动变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*情况二*/</span></span><br><span class="line"><span class="comment">/*-------one.c--------*/</span></span><br><span class="line"><span class="keyword">int</span> b;<span class="comment">//外部变量b的定义式声明</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*-------two.c--------*/</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> b;<span class="comment">//b被定义在另一个文件，则必须声明extern</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="静态内部链接变量"><a href="#静态内部链接变量" class="headerlink" title="静态内部链接变量"></a>静态内部链接变量</h3><p>在所有函数外用static定义的变量，具有静态存储器、文件作用域和内部链接。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> a=<span class="number">1</span>;<span class="comment">//内部链接的变量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">int</span> a;<span class="comment">//使用定义在别处的外部变量a，不是本文件的a。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="静态无链接变量（块作用域的静态变量）"><a href="#静态无链接变量（块作用域的静态变量）" class="headerlink" title="静态无链接变量（块作用域的静态变量）"></a>静态无链接变量（块作用域的静态变量）</h3><p>具有块作用域、无链接，但是具有静态存储期。</p>
<p>静态的意思是变量在内存中原地不动，并不是说值不变。变量具有和自动变量一样的作用域，但是程序离开该函数的时候，变量不会消失。</p>
<p>在块中以static声明变量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a=<span class="number">0</span>;<span class="comment">//静态无链接变量</span></span><br><span class="line">    a++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//每次调用的时候a的值都还在</span></span><br><span class="line">fun();<span class="comment">//a=1</span></span><br><span class="line">fun();<span class="comment">//a=2</span></span><br><span class="line">fun();<span class="comment">//a=3</span></span><br></pre></td></tr></table></figure>
<p>不能在函数的形参中使用static。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">static</span> <span class="keyword">int</span> a)</span></span>;<span class="comment">//不允许</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>《C Primer Plus》</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux网络内核源码分析|重要数据结构</title>
    <url>/2019/12/20/Linux%E7%BD%91%E7%BB%9C%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E9%87%8D%E8%A6%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>内核版本：linux-2.6.8.1</p>
<h2 id="linux目录解析"><a href="#linux目录解析" class="headerlink" title="linux目录解析"></a>linux目录解析</h2><img src="/2019/12/20/Linux网络内核源码分析-重要数据结构/image-20191218002916745.png">
<h2 id="网络内核布局"><a href="#网络内核布局" class="headerlink" title="网络内核布局"></a>网络内核布局</h2><img src="/2019/12/20/Linux网络内核源码分析-重要数据结构/image-20191220132906019.png">
<img src="/2019/12/20/Linux网络内核源码分析-重要数据结构/image-20191220132646373.png">
<h1 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h1><h2 id="struct-sk-buff-struct-sk-buff-head"><a href="#struct-sk-buff-struct-sk-buff-head" class="headerlink" title="struct sk_buff, struct sk_buff_head"></a>struct sk_buff, struct sk_buff_head</h2><blockquote>
<p>skbuff.h</p>
</blockquote>
<p>sk_buff是套接字缓冲区类型，用来管理网络数据包，为发/收的网络数据提供存储区域和操作方法。</p>
<p>sk_buff_head管理一个双向链表，来组织sk_buff。</p>
<img src="/2019/12/20/Linux网络内核源码分析-重要数据结构/image-20191220134051960.png">
<p>sk_buff与数据存储</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;<span class="comment">//struct sk_buff</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> *head,<span class="comment">//缓冲区头指针</span></span><br><span class="line">		*data,<span class="comment">//数据块头指针</span></span><br><span class="line">		*tail,<span class="comment">//数据块尾指针</span></span><br><span class="line">		*end;<span class="comment">//缓冲区尾指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2019/12/20/Linux网络内核源码分析-重要数据结构/image-20191220141837701.png">
<p>sk_buff用union定义的三个协议头部指针：h, nh, mac。每个union有一个用于初始化的raw指针。采用tcp协议的数据包从第三层递交到第四层时指针的变化情况。</p>
<img src="/2019/12/20/Linux网络内核源码分析-重要数据结构/image-20191220143237080.png">
<p>sk_buff-&gt;end指针指向数据报分片信息，数据包分片由struct skb_shared_info管理。</p>
<h2 id="alloc-skb"><a href="#alloc-skb" class="headerlink" title="alloc_skb()"></a>alloc_skb()</h2><blockquote>
<p>skbuff.c</p>
</blockquote>
<p>创建套接字缓冲区并初始化，建立了sk_buff和struct skb_shared_info的关系。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;<span class="comment">//alloc_skb</span></span><br><span class="line">    <span class="comment">//分配一个struct sk_buff结构体</span></span><br><span class="line">	skb = kmem_cache_alloc(skbuff_head_cache,</span><br><span class="line">			       gfp_mask &amp; ~__GFP_DMA);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">	<span class="comment">// 初始化数据区指针</span></span><br><span class="line">	skb-&gt;head = data;</span><br><span class="line">	skb-&gt;data = data;</span><br><span class="line">	skb-&gt;tail = data;</span><br><span class="line">	skb-&gt;end  = data + size;</span><br><span class="line">	<span class="comment">// 初始化struct skb_shared_info结构内容</span></span><br><span class="line">	<span class="comment">// #define skb_shinfo(SKB) ((struct skb_shared_info *)((SKB)-&gt;end))</span></span><br><span class="line">	atomic_set(&amp;(skb_shinfo(skb)-&gt;dataref), <span class="number">1</span>);</span><br><span class="line">	skb_shinfo(skb)-&gt;nr_frags  = <span class="number">0</span>;</span><br><span class="line">	skb_shinfo(skb)-&gt;tso_size = <span class="number">0</span>;</span><br><span class="line">	skb_shinfo(skb)-&gt;tso_segs = <span class="number">0</span>;</span><br><span class="line">	skb_shinfo(skb)-&gt;frag_list = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2019/12/20/Linux网络内核源码分析-重要数据结构/image-20191220170347859.png">
<h2 id="skb-put-skb-trim-skb-push-skb-pull-skb-reserve"><a href="#skb-put-skb-trim-skb-push-skb-pull-skb-reserve" class="headerlink" title="skb_put(), skb_trim(), skb_push(), skb_pull(), skb_reserve()"></a>skb_put(), skb_trim(), skb_push(), skb_pull(), skb_reserve()</h2><blockquote>
<p>skbuff.h</p>
</blockquote>
<p>skb_put()用来在数据区后加某协议尾部；调整tail，增加len。</p>
<p>skb_trim()用来去掉数据包的协议尾部；调整tail, 减少len。</p>
<p>skb_push()用来在数据区前加某协议头部；调整data，增加len。</p>
<p>skb_pull()用来去掉数据包的协议头部；调整data，减少len。</p>
<p>skb_reserve()用来在数据区创建存储协议头部的空间。应用：方便skb_push添加头部；调整数据区大小。</p>
<img src="/2019/12/20/Linux网络内核源码分析-重要数据结构/image-20191220174418888.png">
<h2 id="skb-queue-head-skb-queue-tail"><a href="#skb-queue-head-skb-queue-tail" class="headerlink" title="skb_queue_head(), skb_queue_tail()"></a>skb_queue_head(), skb_queue_tail()</h2><blockquote>
<p>skbuff.h</p>
</blockquote>
<p>skb_queue_head() —&gt; _skb_queue_head()，在套接字缓冲区链表头部添加一个缓冲区。</p>
<p>skb_dequeue() —&gt; _skb_dequeue()，把排在头部的缓冲区从套接字缓冲区链表中移走，返回该缓冲区。</p>
<p>skb_queue_tail() —&gt; _skb_queue_tail()，在套接字缓冲区链表尾部添加一个缓冲区。</p>
<p>skb_dequeue_tail() —&gt; _skb_dequeue_tail()，从套接字缓冲区链表尾部移走一个缓冲区。</p>
<p>其中，套接字缓冲区链表即struct sk_buff_head <em>list，涉及增加操作时参数有待增加缓冲区struct sk_buff </em>newsk。</p>
<h1 id="网络设备"><a href="#网络设备" class="headerlink" title="网络设备"></a>网络设备</h1><h2 id="struct-net-device"><a href="#struct-net-device" class="headerlink" title="struct net_device"></a>struct net_device</h2><p>管理网络设备的数据结构。含：通用字段、硬件配置字段、网络层数据字段、物理层数据字段、设备驱动程序中的函数。</p>
<blockquote>
<p>include/linux/netdevice.h</p>
</blockquote>
<p><strong>通用字段</strong>：设备名称、next指针指向下一个net_device、设备状态state、网络设备索引值ifindex(用来标志网络设备以便快速定位，设备被创建后由dev_get_index函数分配)、refcnt表示网络设备的引用次数。</p>
<img src="/2019/12/20/Linux网络内核源码分析-重要数据结构/image-20191229180604542.png">
<p><strong>硬件配置字段</strong>：内存共享字段（描述网络适配器与内核共享的内存空间，指定发送包和接受包所在的区域）、I/O基地址（用于驱动程序搜索设备）、设备使用的中断号irq、分配给设备的DMA通道号、多端口设备使用的不同端口if_port（网络介质类型决定）。</p>
<p><strong>物理层数据字段</strong>：指定2层协议头部长度、最大传输单元mtu（以太网1500byte）、网络设备输出队列的最大长度、网络设备类型type、地址字段（广播地址、多播地址表等）。</p>
<p><strong>网络层数据字段</strong>：协议信息字段（xxx_ptr，指向xxx协议信息）、网络地址信息字段（协议地址族family例如AF_INET、协议地址长度、网络设备地址pa_addr）等。</p>
<p><strong>设备驱动程序中的函数指针</strong>：</p>
<ul>
<li>int (*init)指向设备初始化函数，注册设备时调用，初始化struct net_device；</li>
<li>void (*uninit)指向注销设备函数，删除设备时调用；</li>
<li>int (*open)指向打开设备接口的函数，注册设备需要的系统资源（I/O端口、irq、dma）；</li>
<li>int (*stop)指向停止设备的函数；</li>
<li>…</li>
</ul>
<h2 id="网络设备的创建和注册过程"><a href="#网络设备的创建和注册过程" class="headerlink" title="网络设备的创建和注册过程"></a>网络设备的创建和注册过程</h2><img src="/2019/12/20/Linux网络内核源码分析-重要数据结构/image-20191229181906396.png">
<p>一个网络设备被使用前，需要先被创建成为一个struct net_device并注册。下面描述注册过程：</p>
<p>设备驱动被编译成模块，内核在加载模块时进行初始化，调用init_module。init_module依次调用alloc_etherdev、do_netcard_probe、register_netdev。</p>
<p>alloc_etherdev创建一个以太网设备，返回管理该设备的struct net_device，其中alloc_netdev函数为新创建的网络设备分配struct net_device结构空间，ether_setup初始化与以太网相关的设备信息并将协议相关的函数指针添加到struct net_device结构中。</p>
<blockquote>
<p>driver/net/net_init.c</p>
</blockquote>
<p>do_netcard_probe设置struct net_device_device主要字段。</p>
<p>register_netdev函数注册该设备，最后调用register_netdevice向dev_base链表添加设备。不需要网络设备时需要unregister_netdev函数注销设备，关闭活动状态的设备并从dev_base链表中删除设备。</p>
<blockquote>
<p>net/core/dev.c</p>
</blockquote>
<h2 id="网络设备的开启与关闭"><a href="#网络设备的开启与关闭" class="headerlink" title="网络设备的开启与关闭"></a>网络设备的开启与关闭</h2><blockquote>
<p>net/core/dev.c</p>
</blockquote>
<p><strong>开启网络设备函数dev_open(struct net_device *dev)</strong>。如果网络设备已经激活或者它尚未被注册，函数返回错误信息。</p>
<ul>
<li>判断设备是否激活；</li>
<li>使用set_bit函数修改设备状态为<strong>__LINK_STATE_START</strong>，调用net_device中的open指向函数设置该设备；</li>
<li>激活网络设备的队列和调度器；</li>
<li>将事件(<strong>NETDEV_UP</strong>)登记到通知链：notifier_call_chain(&amp;netdev_chain,事件,dev)。</li>
</ul>
<p><strong>关闭网络设备函数dev_close(struct net_device *dev)</strong>。</p>
<ul>
<li>如果网络设备未被激活，则不需要关闭；</li>
<li>将事件(NETDEV_GOING_DOWN)登记到通知链：notifier_call_chain(&amp;netdev_chain,事件名,dev)；</li>
<li>删除包调度器中的相应信息：dev_deactivate；</li>
<li>清除设备的活动状态：clear_bit；</li>
<li>调用net_device中的stop指向函数，执行停止操作。</li>
</ul>
<h2 id="通知链"><a href="#通知链" class="headerlink" title="通知链"></a>通知链</h2><blockquote>
<p>kernel/sys.c</p>
</blockquote>
<p><strong>struct notifier_block</strong>类型定义了通知链中每个元素的结构。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">notifier_block</span>&#123;</span></span><br><span class="line">    <span class="comment">//表示这个元素所记录的函数</span></span><br><span class="line">    <span class="keyword">int</span> (*notifier_call)(struct notifier_block *self,<span class="keyword">unsigned</span> <span class="keyword">long</span>,<span class="keyword">void</span> *);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">notifier_block</span> *<span class="title">next</span>;</span><span class="comment">//指向下一个元素</span></span><br><span class="line">    <span class="keyword">int</span> priority;<span class="comment">//描述优先级</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>通知链注册事件函数notifier_chain_register(</strong>notifier_block列表,notifier_block待登记块<strong>)</strong>。可以向通知链中等级一个事件，事件发生时可以从notifier_block链表中找到该事件对应的元素，执行记录的函数。</p>
<p><strong>通知链注销事件函数notifier_chain_unregister(</strong>notifier_block列表,notifier_block待注销块<strong>)</strong>。可以向通知链中注销一个事件。</p>
<p>事件发生时，使用<strong>notifier_call_chain(通知链名，事件名，void*)</strong>。向某个通知链表发送消息，按顺序<strong>调用链表块中记录的函数</strong>。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>网络</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统丨概述</title>
    <url>/2019/10/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%A8%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h2 id="操作系统定义"><a href="#操作系统定义" class="headerlink" title="操作系统定义"></a>操作系统定义</h2><h3 id="统一定义"><a href="#统一定义" class="headerlink" title="统一定义"></a>统一定义</h3><p>操作系统是控制和管理计算机系统的硬件和软件资源、合理地组织计算机工作流程及方便用户使用的程序和数据的集合。</p>
<p><strong>目的</strong>：提高计算机系统的效率、增强系统的处理能力、充分发挥系统资源利用率、方便用户使用。</p>
<h3 id="作为最基本的系统软件"><a href="#作为最基本的系统软件" class="headerlink" title="作为最基本的系统软件"></a>作为最基本的系统软件</h3><p>操作系统是计算机系统软件的重要组成部分，其物质基础是系统硬件。</p>
<blockquote>
<p>计算机系统资源包括：系统硬件和系统软件</p>
</blockquote>
<h3 id="作为资源管理器"><a href="#作为资源管理器" class="headerlink" title="作为资源管理器"></a>作为资源管理器</h3><p>跟踪资源状态：掌握资源分配的全局信息。分配资源、回收资源、保护资源。</p>
<blockquote>
<p>系统资源四大类：处理机、存储器、I/O设备、信息</p>
<p>操作系统的四类管理器：处理机管理、存储管理、设备管理、信息管理</p>
</blockquote>
<h3 id="作为虚拟机"><a href="#作为虚拟机" class="headerlink" title="作为虚拟机"></a>作为虚拟机</h3><p>是用户和计算机之间的接口。</p>
<blockquote>
<p>操作系统为用户提供接口：命令接口、编程接口</p>
</blockquote>
<hr>
<h2 id="操作系统分类"><a href="#操作系统分类" class="headerlink" title="操作系统分类"></a>操作系统分类</h2><h3 id="单道批处理系统"><a href="#单道批处理系统" class="headerlink" title="单道批处理系统"></a>单道批处理系统</h3><p>同一批作业自动依次更替，CPU和I/O设备使用忙闲不均。</p>
<h3 id="多道批处理系统"><a href="#多道批处理系统" class="headerlink" title="多道批处理系统"></a>多道批处理系统</h3><ul>
<li><p>优点：作业流程自动化，资源利用率高吞吐量大。</p>
</li>
<li><p>缺点：用户交互性差，调试程序困难；作业平均周转时间长。</p>
</li>
</ul>
<h3 id="分时系统——多道程序设计的自然延伸"><a href="#分时系统——多道程序设计的自然延伸" class="headerlink" title="分时系统——多道程序设计的自然延伸"></a>分时系统——多道程序设计的自然延伸</h3><p>多个程序分时共享硬件和软件资源。</p>
<ul>
<li><p>按时间片分配：各程序在CPU上执行的轮换时间。</p>
</li>
<li><p>特点：同时性、交互性、独立性、及时性。</p>
</li>
</ul>
<blockquote>
<p>同时性：多个用户同时工作；</p>
<p>独立性：各用户独立操作互不干扰；</p>
<p>及时性：系统能及时对用户做出响应；</p>
<p>交互性（基本属性）：用户交互式地向系统提出请求。</p>
</blockquote>
<h3 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h3><p>能够在<strong>制定或者确定的时间内</strong>完成系统功能和对外部或内部、同步或异步时间做出相应的系统。在实时计算中，系统的正确性依赖于计算的逻辑结果和结果产生的时间。</p>
<blockquote>
<p>硬实时系统：必须在规定的时刻或时间范围内完成任务。</p>
<p>软实时系统：接受偶尔违反最终时限的情况。</p>
</blockquote>
<p>保证实时性的关键：高精度计时系统、多级中断机制、实时调度机制。</p>
<h3 id="网络操作系统"><a href="#网络操作系统" class="headerlink" title="网络操作系统"></a>网络操作系统</h3><p>在通常操作系统功能的基础上，提供网络通信和网络服务功能的操作系统。</p>
<ul>
<li><p>目标：相互通信、资源共享；</p>
</li>
<li><p>功能：网络通信功能、网络资源管理、网络服务、网络管理、互操作。</p>
</li>
</ul>
<h3 id="分布式操作系统"><a href="#分布式操作系统" class="headerlink" title="分布式操作系统"></a>分布式操作系统</h3><p>分布式操作系统的所有系统任务可在系统中任何处理机上运行，自动实现全系统范围内的任务分配并自动调度各处理机的工作负载。</p>
<p>特征：</p>
<ul>
<li><p>功能和任务的分布；</p>
</li>
<li><p><strong>透明性</strong>：资源共享，资源对于用户透明；</p>
</li>
<li><p><strong>自治性</strong>：多个主机处于平等地位，无主从关系。</p>
</li>
</ul>
<h3 id="多处理机系统-并行计算系统"><a href="#多处理机系统-并行计算系统" class="headerlink" title="多处理机系统/并行计算系统"></a>多处理机系统/并行计算系统</h3><p>优点：</p>
<ul>
<li><p>增加系统的吞吐量：采用N个处理器的加速比小于N，因为有额外开销，竞争共享资源</p>
</li>
<li><p>提高系统可靠性：故障时系统降级运行，处理器故障会导致系统变慢而不是停止。</p>
<ul>
<li>适度退化：根据剩余有效硬件的级别按照比例继续提供服务的能力。</li>
<li>容错：系统超过适度退化，容忍某部件错误。</li>
</ul>
</li>
<li><p>规模经济：低于多个单处理器系统的价格，因为可以共享外设、大容量存储和电源供给。</p>
</li>
</ul>
<p>分类1:是否对称处理源于硬件或软件</p>
<ul>
<li><p><strong>非对称式多处理ASMP</strong>：主从模式</p>
<ul>
<li>一个主处理器：运行OS，管理整个系统的资源，为从处理器分配任务。</li>
<li>从处理器：多个，执行应用程序或I/O处理。</li>
<li>特点：不同性质任务的负载不均，可靠性不高，不易移植。</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>对称式多处理SMP</strong>（常用的多处理机系统）</p>
<ul>
<li>os交替在各个处理器上执行，各处理器平等。</li>
<li>任务负载平均，性能调节容易，可同时执行多进程。</li>
<li>应当仔细控制I/O；防止CPU先忙不均，处理器共享一定的数据结构即可。</li>
</ul>
</li>
</ul>
<p>分类2：耦合类型</p>
<ul>
<li><p><strong>紧密耦合</strong>：各处理及之间通过快速总线或开关阵列相连，共享内存，整体系统由一个统一的OS管理。</p>
</li>
<li><p><strong>松散耦合</strong>：各处理及带有各自的存储器、I/O设备和操作系统，通过通道或通信线路相连。每个处理及上独立运行OS。</p>
</li>
</ul>
<h3 id="多核系统"><a href="#多核系统" class="headerlink" title="多核系统"></a>多核系统</h3><p>多核系统是多处理器系统，但多处理系统不一定都是多核的。</p>
<p>集成多个计算核到单个CPU芯片。</p>
<blockquote>
<p>多处理机系统是多个CPU。</p>
</blockquote>
<h3 id="集群系统"><a href="#集群系统" class="headerlink" title="集群系统"></a>集群系统</h3><p>是多处理器系统，是松散耦合的（由两个或多个独立系统或节点组成），可以是对称的或非对称的。</p>
<ul>
<li>提供高可用性服务：集群中一个或多个系统出错仍可继续提供服务，代价是增加冗余。</li>
<li>提供高性能计算：应用程序专门编写以利用集群。</li>
</ul>
<blockquote>
<p>并行计算：程序分成多部分，每部分运行在各个计算核上，所有节点的结果合并在一起形成解决方案。</p>
</blockquote>
<h3 id="嵌入式操作系统"><a href="#嵌入式操作系统" class="headerlink" title="嵌入式操作系统"></a>嵌入式操作系统</h3><p>以应用为中心、以计算技术为基础、软硬件可裁剪，适应应用系统，对功能、可靠性、成本、体积、功耗严格要求的专用计算机系统。</p>
<hr>
<h2 id="操作系统功能"><a href="#操作系统功能" class="headerlink" title="操作系统功能"></a>操作系统功能</h2><ul>
<li>处理机管理：进程控制、进程同步、进程通信、进程调度。</li>
<li>存储管理：内存分配、内存保护、地址映射、内存扩充。</li>
<li>设备管理：缓冲管理、设备分配、设备处理、虚拟设备。</li>
<li>文件管理：文件存储空间的管理、目录管理、文件的读\写管理和保护。</li>
<li>用户接口：命令接口、程序接口、图形接口。</li>
</ul>
<hr>
<h2 id="操作系统特征"><a href="#操作系统特征" class="headerlink" title="操作系统特征"></a>操作系统特征</h2><ul>
<li><p>并发性（现代操作系统的基本特征）：多个事件在同一时间段内发生。</p>
</li>
<li><p>共享性 （现代操作系统的基本特征）</p>
<ul>
<li>系统中的资源可供内存中多个并发执行的进程共同使用。</li>
<li>互斥共享方式，临界资源。</li>
<li>同时访问方式。</li>
</ul>
</li>
</ul>
<ul>
<li><p>虚拟性：一个物理实体→若干个逻辑上的对应。</p>
<ul>
<li>虚拟处理机技术：多道程序并发执行分时使用一台处理机。</li>
<li>虚拟存储器技术：一台机器的物理存储器变为虚拟存储器，从逻辑上扩充存储器的容量。</li>
<li>虚拟设备技术：一台物理I/O设备虚拟为多台逻辑上的I/O设备，允许每个用户占用一台逻辑上的I/O设备。（SPOOLing技术）</li>
</ul>
</li>
</ul>
<ul>
<li><p>异步性（不确定性）</p>
<ul>
<li>进程的执行顺序、执行时间的不确定。</li>
<li>运行速度不可预知。分时系统中多个进程并发执行，不可预知每个进程的运行推进快慢；无论快慢，结果应该相同，通过进程互斥和同步手段来保证。</li>
<li>难以重现系统在某个时刻的状态。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Python丨tkinter丨窗口与标签(label)</title>
    <url>/2019/10/04/Python%E4%B8%A8tkinter%E4%B8%A8%E7%AA%97%E5%8F%A3%E4%B8%8E%E6%A0%87%E7%AD%BE-label/</url>
    <content><![CDATA[<h2 id="Tkinter简介"><a href="#Tkinter简介" class="headerlink" title="Tkinter简介"></a>Tkinter简介</h2><p>Tkinter是Python的标准GUI库。Python使用Tkinter可以快速地创建GUI应用程序。创建一个GUI程序的流程是：</p>
<ul>
<li><p>导入tkinter模块</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tkinter <span class="keyword">as</span> tk</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建和初始化一个tk实例</p>
</li>
<li>创建控件、摆放控件</li>
<li>进入消息循环</li>
</ul>
<h2 id="初始化窗口"><a href="#初始化窗口" class="headerlink" title="初始化窗口"></a>初始化窗口</h2><p>导入包后，即可创建tk实例（一个窗口），指定窗口名称、大小及背景色等属性。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">window = tk.Tk()</span><br><span class="line">window.title(<span class="string">'ha!'</span>) <span class="comment">#指定窗口名称</span></span><br><span class="line">window.geometry(<span class="string">'400x500'</span>) <span class="comment">#指定窗口大小</span></span><br><span class="line">window.configure(background=<span class="string">'white'</span>) <span class="comment">#指定窗口背景色，白色很好看！</span></span><br></pre></td></tr></table></figure>
<p>接下来就可以创建控件、摆放控件了。后续会介绍各个控件的基本用法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">控件们</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
<p>在所有控件之后，进入消息循环即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">window.mainloop()</span><br></pre></td></tr></table></figure>
<p>运行，显示效果如下：</p>

<h2 id="标签-label"><a href="#标签-label" class="headerlink" title="标签(label)"></a>标签(label)</h2><p>最简单的控件使用方式：创建、摆放到窗口。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l_hello=tk.Label(window, text=<span class="string">'hello!'</span>,bg=<span class="string">'white'</span>,</span><br><span class="line">		font=(<span class="string">'Arial'</span>,<span class="number">9</span>),width=<span class="number">25</span>,height=<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 指定master为window（tk实例)，文本内容为'hello!',背景颜色为白色，</span></span><br><span class="line">		<span class="comment"># 字体，宽度，高度</span></span><br><span class="line">l_hello.pack()</span><br><span class="line"><span class="comment"># pack()函数是将控件放在窗口中，默认情况为居中自上而下依次摆放。</span></span><br></pre></td></tr></table></figure>
<p>把这段代码插入窗口初始化和消息循环中间，运行看看：</p>

<p>‘hello！’就可以显示出来了！</p>
<p>不过，这个text被指定为静态的字符串。如果需要动态指定字符串则可以将text替换为textvariable。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">var=tk.StringVar()</span><br><span class="line">l_hello=tk.Label(window, textvariable=var,bg=<span class="string">'white'</span>,</span><br><span class="line">		font=(<span class="string">'Arial'</span>,<span class="number">9</span>),width=<span class="number">25</span>,height=<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 指定master为window（tk实例)，文本内容为字符串变量,背景颜色为白色，</span></span><br><span class="line">		<span class="comment"># 字体，宽度，高度</span></span><br><span class="line">l_hello.pack()</span><br><span class="line"><span class="comment"># pack()函数是将控件放在窗口中，默认情况为居中自上而下依次摆放。</span></span><br></pre></td></tr></table></figure>
<p>这个var可以在用户交互的过程中，动态指定。例如，用户点击按钮，按钮激发一个函数，函数中给var赋值，并在窗口中显示出来。</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>tkinter</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo+git丨个人博客搭建</title>
    <url>/2019/10/02/hexo-git%E4%B8%A8%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><ul>
<li><p>下载并安装node.js，<a href="https://nodejs.org/en/download/。">https://nodejs.org/en/download/。</a></p>
</li>
<li><p>下载并安装git，<a href="https://git-scm.com/downloads。">https://git-scm.com/downloads。</a></p>
</li>
<li><p>安装cnpm，在命令行工具输入：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry=https:<span class="comment">//registry.npm.taobao.org</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>安装hexo，在命令行工具输入：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cnpm install -g hexo-cli</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="本地搭建博客"><a href="#本地搭建博客" class="headerlink" title="本地搭建博客"></a>本地搭建博客</h2><ul>
<li><p>在自己喜欢的地方新建一个空白文件夹，例如：“D:\BLOG”。</p>
</li>
<li><p>在“D:\BLOG”路径下打开命令行工具（以下操作都基于此路径，以后不再重复提示），输入命令进行初始化，如果是windows系统：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>
<p>如果是linux系统：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo hexo init</span><br></pre></td></tr></table></figure>
</li>
<li><p>打开hexo服务器：输入如下命令，访问 <strong>localhost:4000</strong> 可以看到默认主题(landscape)的个人主页。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="写博客"><a href="#写博客" class="headerlink" title="写博客"></a>写博客</h2><ul>
<li><p>新建博客，输入命令：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hexo n <span class="string">"一篇博客"</span></span><br></pre></td></tr></table></figure>
<p>双引号内是博客的篇名，创建后可以在本地 <strong>D:\BLOG\source_posts</strong> 看到 <strong>一篇博客.md</strong> 文件生成，在此文件中进行博客创作并保存。推荐使用typora来编辑md文件。</p>
</li>
<li><p>生成博客，输入命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>
</li>
<li><p>打开hexo服务器：输入如下命令，访问 <strong>localhost:4000</strong> 可以看到自己的博客：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="将博客部署到github"><a href="#将博客部署到github" class="headerlink" title="将博客部署到github"></a>将博客部署到github</h2><ul>
<li><p>下载hexo-deployer-git，输入命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建repo，注意repo命名则为后续访问博客的url。复制HTTPS。</p>
</li>
<li><p>修改<strong>D:\BLOG\_config.yml</strong>文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type:</span><br><span class="line">  repo:</span><br><span class="line">  branch:</span><br></pre></td></tr></table></figure>
<p>改为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: #你刚复制的HTTPS：http:/github.com/用户名/repo名.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
</li>
<li><p>清理和生成博客，输入命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br></pre></td></tr></table></figure>
</li>
<li><p>部署到github，输入命令：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>接下来就可以通过<strong>你的HTTPS</strong>来访问你的博客了。</p>
<p>之后如果博客变更，则可以执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><ul>
<li><p>找主题资源。可以通过<strong><a href="https://hexo.io/themes">https://hexo.io/themes</a></strong>自己找找主题；可以通过github找主题。</p>
</li>
<li><p>将主题资源clone到<strong>D:\BLOG\themes\【主题名】</strong>。</p>
<p>此处用github上的一个主题项目来作例：<strong><a href="https://github.com/theme-next/hexo-theme-next">https://github.com/theme-next/hexo-theme-next</a></strong></p>
<p>执行命令，next作为主题名：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改<strong>D:\BLOG\_config.yml</strong>文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: landscape</span><br></pre></td></tr></table></figure>
<p>改为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: next</span><br></pre></td></tr></table></figure>
</li>
<li><p>输入命令更新并查看样式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="hexo-themes-主题推荐（个人）"><a href="#hexo-themes-主题推荐（个人）" class="headerlink" title="hexo-themes 主题推荐（个人）"></a>hexo-themes 主题推荐（个人）</h3><ul>
<li><a href="https://siricee.github.io/hexo-theme-Chic/">https://siricee.github.io/hexo-theme-Chic/</a></li>
<li><a href="https://probberechts.github.io/hexo-theme-cactus/cactus-dark/public/">https://probberechts.github.io/hexo-theme-cactus/cactus-dark/public/</a></li>
<li><a href="https://chengkang.me/hexo-theme-qna/">https://chengkang.me/hexo-theme-qna/</a></li>
<li>白色、简约、经典：<a href="https://theme-next.org/">https://theme-next.org/</a></li>
<li>暗色、简洁：<a href="https://lyndonoc.github.io/">https://lyndonoc.github.io/</a></li>
<li>白色、简洁、汉字：<a href="https://shiolife.cn/lagom/">https://shiolife.cn/lagom/</a></li>
<li>古早、小黄人：<a href="http://blackshow.me/">http://blackshow.me/</a></li>
</ul>
<h3 id="文章折叠和“阅读全文”的设置"><a href="#文章折叠和“阅读全文”的设置" class="headerlink" title="文章折叠和“阅读全文”的设置"></a>文章折叠和“阅读全文”的设置</h3><ul>
<li><a href="https://www.jianshu.com/p/78c218f9d1e7">https://www.jianshu.com/p/78c218f9d1e7</a></li>
</ul>
<h3 id="进阶设置"><a href="#进阶设置" class="headerlink" title="进阶设置"></a>进阶设置</h3><p>关于浏览量统计等杂七杂八：<a href="http://yearito.cn/posts/hexo-advanced-settings.html">http://yearito.cn/posts/hexo-advanced-settings.html</a></p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>教程</tag>
      </tags>
  </entry>
</search>
